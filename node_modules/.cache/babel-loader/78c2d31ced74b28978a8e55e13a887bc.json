{"ast":null,"code":"/**\n * Copyright 2016, 2019 Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Bucketer API for determining the variation id from the specified parameters\n */\nvar enums = require('../../utils/enums');\n\nvar murmurhash = require('murmurhash');\n\nvar sprintf = require('@optimizely/js-sdk-utils').sprintf;\n\nvar ERROR_MESSAGES = enums.ERROR_MESSAGES;\nvar HASH_SEED = 1;\nvar LOG_LEVEL = enums.LOG_LEVEL;\nvar LOG_MESSAGES = enums.LOG_MESSAGES;\nvar MAX_HASH_VALUE = Math.pow(2, 32);\nvar MAX_TRAFFIC_VALUE = 10000;\nvar MODULE_NAME = 'BUCKETER';\nvar RANDOM_POLICY = 'random';\nmodule.exports = {\n  /**\n   * Determines ID of variation to be shown for the given input params\n   * @param  {Object}         bucketerParams\n   * @param  {string}         bucketerParams.experimentId\n   * @param  {string}         bucketerParams.experimentKey\n   * @param  {string}         bucketerParams.userId\n   * @param  {Object[]}       bucketerParams.trafficAllocationConfig\n   * @param  {Array}          bucketerParams.experimentKeyMap\n   * @param  {Object}         bucketerParams.groupIdMap\n   * @param  {Object}         bucketerParams.variationIdMap\n   * @param  {string}         bucketerParams.varationIdMap[].key\n   * @param  {Object}         bucketerParams.logger\n   * @param  {string}         bucketerParams.bucketingId\n   * @return Variation ID that user has been bucketed into, null if user is not bucketed into any experiment\n   */\n  bucket: function (bucketerParams) {\n    // Check if user is in a random group; if so, check if user is bucketed into a specific experiment\n    var experiment = bucketerParams.experimentKeyMap[bucketerParams.experimentKey];\n    var groupId = experiment['groupId'];\n\n    if (groupId) {\n      var group = bucketerParams.groupIdMap[groupId];\n\n      if (!group) {\n        throw new Error(sprintf(ERROR_MESSAGES.INVALID_GROUP_ID, MODULE_NAME, groupId));\n      }\n\n      if (group.policy === RANDOM_POLICY) {\n        var bucketedExperimentId = module.exports.bucketUserIntoExperiment(group, bucketerParams.bucketingId, bucketerParams.userId, bucketerParams.logger); // Return if user is not bucketed into any experiment\n\n        if (bucketedExperimentId === null) {\n          var notbucketedInAnyExperimentLogMessage = sprintf(LOG_MESSAGES.USER_NOT_IN_ANY_EXPERIMENT, MODULE_NAME, bucketerParams.userId, groupId);\n          bucketerParams.logger.log(LOG_LEVEL.INFO, notbucketedInAnyExperimentLogMessage);\n          return null;\n        } // Return if user is bucketed into a different experiment than the one specified\n\n\n        if (bucketedExperimentId !== bucketerParams.experimentId) {\n          var notBucketedIntoExperimentOfGroupLogMessage = sprintf(LOG_MESSAGES.USER_NOT_BUCKETED_INTO_EXPERIMENT_IN_GROUP, MODULE_NAME, bucketerParams.userId, bucketerParams.experimentKey, groupId);\n          bucketerParams.logger.log(LOG_LEVEL.INFO, notBucketedIntoExperimentOfGroupLogMessage);\n          return null;\n        } // Continue bucketing if user is bucketed into specified experiment\n\n\n        var bucketedIntoExperimentOfGroupLogMessage = sprintf(LOG_MESSAGES.USER_BUCKETED_INTO_EXPERIMENT_IN_GROUP, MODULE_NAME, bucketerParams.userId, bucketerParams.experimentKey, groupId);\n        bucketerParams.logger.log(LOG_LEVEL.INFO, bucketedIntoExperimentOfGroupLogMessage);\n      }\n    }\n\n    var bucketingId = sprintf('%s%s', bucketerParams.bucketingId, bucketerParams.experimentId);\n\n    var bucketValue = module.exports._generateBucketValue(bucketingId);\n\n    var bucketedUserLogMessage = sprintf(LOG_MESSAGES.USER_ASSIGNED_TO_VARIATION_BUCKET, MODULE_NAME, bucketValue, bucketerParams.userId);\n    bucketerParams.logger.log(LOG_LEVEL.DEBUG, bucketedUserLogMessage);\n\n    var entityId = module.exports._findBucket(bucketValue, bucketerParams.trafficAllocationConfig);\n\n    if (!entityId) {\n      var userHasNoVariationLogMessage = sprintf(LOG_MESSAGES.USER_HAS_NO_VARIATION, MODULE_NAME, bucketerParams.userId, bucketerParams.experimentKey);\n      bucketerParams.logger.log(LOG_LEVEL.DEBUG, userHasNoVariationLogMessage);\n    } else if (!bucketerParams.variationIdMap.hasOwnProperty(entityId)) {\n      var invalidVariationIdLogMessage = sprintf(LOG_MESSAGES.INVALID_VARIATION_ID, MODULE_NAME);\n      bucketerParams.logger.log(LOG_LEVEL.WARNING, invalidVariationIdLogMessage);\n      return null;\n    } else {\n      var variationKey = bucketerParams.variationIdMap[entityId].key;\n      var userInVariationLogMessage = sprintf(LOG_MESSAGES.USER_HAS_VARIATION, MODULE_NAME, bucketerParams.userId, variationKey, bucketerParams.experimentKey);\n      bucketerParams.logger.log(LOG_LEVEL.INFO, userInVariationLogMessage);\n    }\n\n    return entityId;\n  },\n\n  /**\n   * Returns bucketed experiment ID to compare against experiment user is being called into\n   * @param {Object} group        Group that experiment is in\n   * @param {string} bucketingId  Bucketing ID\n   * @param {string} userId       ID of user to be bucketed into experiment\n   * @param {Object} logger       Logger implementation\n   * @return {string} ID of experiment if user is bucketed into experiment within the group, null otherwise\n   */\n  bucketUserIntoExperiment: function (group, bucketingId, userId, logger) {\n    var bucketingKey = sprintf('%s%s', bucketingId, group.id);\n\n    var bucketValue = module.exports._generateBucketValue(bucketingKey);\n\n    logger.log(LOG_LEVEL.DEBUG, sprintf(LOG_MESSAGES.USER_ASSIGNED_TO_EXPERIMENT_BUCKET, MODULE_NAME, bucketValue, userId));\n    var trafficAllocationConfig = group.trafficAllocation;\n\n    var bucketedExperimentId = module.exports._findBucket(bucketValue, trafficAllocationConfig);\n\n    return bucketedExperimentId;\n  },\n\n  /**\n   * Returns entity ID associated with bucket value\n   * @param  {string}   bucketValue\n   * @param  {Object[]} trafficAllocationConfig\n   * @param  {number}   trafficAllocationConfig[].endOfRange\n   * @param  {number}   trafficAllocationConfig[].entityId\n   * @return {string}   Entity ID for bucketing if bucket value is within traffic allocation boundaries, null otherwise\n   */\n  _findBucket: function (bucketValue, trafficAllocationConfig) {\n    for (var i = 0; i < trafficAllocationConfig.length; i++) {\n      if (bucketValue < trafficAllocationConfig[i].endOfRange) {\n        return trafficAllocationConfig[i].entityId;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Helper function to generate bucket value in half-closed interval [0, MAX_TRAFFIC_VALUE)\n   * @param  {string} bucketingKey String value for bucketing\n   * @return {string} the generated bucket value\n   * @throws If bucketing value is not a valid string\n   */\n  _generateBucketValue: function (bucketingKey) {\n    try {\n      // NOTE: the mmh library already does cast the hash value as an unsigned 32bit int\n      // https://github.com/perezd/node-murmurhash/blob/master/murmurhash.js#L115\n      var hashValue = murmurhash.v3(bucketingKey, HASH_SEED);\n      var ratio = hashValue / MAX_HASH_VALUE;\n      return parseInt(ratio * MAX_TRAFFIC_VALUE, 10);\n    } catch (ex) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_BUCKETING_ID, MODULE_NAME, bucketingKey, ex.message));\n    }\n  }\n};","map":{"version":3,"sources":["/home/abhishek/Music/contentstack-reactjs-ab-testing/node_modules/@optimizely/optimizely-sdk/lib/core/bucketer/index.js"],"names":["enums","require","murmurhash","sprintf","ERROR_MESSAGES","HASH_SEED","LOG_LEVEL","LOG_MESSAGES","MAX_HASH_VALUE","Math","pow","MAX_TRAFFIC_VALUE","MODULE_NAME","RANDOM_POLICY","module","exports","bucket","bucketerParams","experiment","experimentKeyMap","experimentKey","groupId","group","groupIdMap","Error","INVALID_GROUP_ID","policy","bucketedExperimentId","bucketUserIntoExperiment","bucketingId","userId","logger","notbucketedInAnyExperimentLogMessage","USER_NOT_IN_ANY_EXPERIMENT","log","INFO","experimentId","notBucketedIntoExperimentOfGroupLogMessage","USER_NOT_BUCKETED_INTO_EXPERIMENT_IN_GROUP","bucketedIntoExperimentOfGroupLogMessage","USER_BUCKETED_INTO_EXPERIMENT_IN_GROUP","bucketValue","_generateBucketValue","bucketedUserLogMessage","USER_ASSIGNED_TO_VARIATION_BUCKET","DEBUG","entityId","_findBucket","trafficAllocationConfig","userHasNoVariationLogMessage","USER_HAS_NO_VARIATION","variationIdMap","hasOwnProperty","invalidVariationIdLogMessage","INVALID_VARIATION_ID","WARNING","variationKey","key","userInVariationLogMessage","USER_HAS_VARIATION","bucketingKey","id","USER_ASSIGNED_TO_EXPERIMENT_BUCKET","trafficAllocation","i","length","endOfRange","hashValue","v3","ratio","parseInt","ex","INVALID_BUCKETING_ID","message"],"mappings":"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","sourcesContent":["/**\n * Copyright 2016, 2019 Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Bucketer API for determining the variation id from the specified parameters\n */\nvar enums = require('../../utils/enums');\nvar murmurhash = require('murmurhash');\nvar sprintf = require('@optimizely/js-sdk-utils').sprintf;\n\nvar ERROR_MESSAGES = enums.ERROR_MESSAGES;\nvar HASH_SEED = 1;\nvar LOG_LEVEL = enums.LOG_LEVEL;\nvar LOG_MESSAGES = enums.LOG_MESSAGES;\nvar MAX_HASH_VALUE = Math.pow(2, 32);\nvar MAX_TRAFFIC_VALUE = 10000;\nvar MODULE_NAME = 'BUCKETER';\nvar RANDOM_POLICY = 'random';\n\nmodule.exports = {\n  /**\n   * Determines ID of variation to be shown for the given input params\n   * @param  {Object}         bucketerParams\n   * @param  {string}         bucketerParams.experimentId\n   * @param  {string}         bucketerParams.experimentKey\n   * @param  {string}         bucketerParams.userId\n   * @param  {Object[]}       bucketerParams.trafficAllocationConfig\n   * @param  {Array}          bucketerParams.experimentKeyMap\n   * @param  {Object}         bucketerParams.groupIdMap\n   * @param  {Object}         bucketerParams.variationIdMap\n   * @param  {string}         bucketerParams.varationIdMap[].key\n   * @param  {Object}         bucketerParams.logger\n   * @param  {string}         bucketerParams.bucketingId\n   * @return Variation ID that user has been bucketed into, null if user is not bucketed into any experiment\n   */\n  bucket: function(bucketerParams) {\n    // Check if user is in a random group; if so, check if user is bucketed into a specific experiment\n    var experiment = bucketerParams.experimentKeyMap[bucketerParams.experimentKey];\n    var groupId = experiment['groupId'];\n    if (groupId) {\n      var group = bucketerParams.groupIdMap[groupId];\n      if (!group) {\n        throw new Error(sprintf(ERROR_MESSAGES.INVALID_GROUP_ID, MODULE_NAME, groupId));\n      }\n      if (group.policy === RANDOM_POLICY) {\n        var bucketedExperimentId = module.exports.bucketUserIntoExperiment(group,\n                                                                          bucketerParams.bucketingId,\n                                                                          bucketerParams.userId,\n                                                                          bucketerParams.logger);\n\n        // Return if user is not bucketed into any experiment\n        if (bucketedExperimentId === null) {\n          var notbucketedInAnyExperimentLogMessage = sprintf(LOG_MESSAGES.USER_NOT_IN_ANY_EXPERIMENT, MODULE_NAME, bucketerParams.userId, groupId);\n          bucketerParams.logger.log(LOG_LEVEL.INFO, notbucketedInAnyExperimentLogMessage);\n          return null;\n        }\n\n        // Return if user is bucketed into a different experiment than the one specified\n        if (bucketedExperimentId !== bucketerParams.experimentId) {\n          var notBucketedIntoExperimentOfGroupLogMessage = sprintf(LOG_MESSAGES.USER_NOT_BUCKETED_INTO_EXPERIMENT_IN_GROUP, MODULE_NAME, bucketerParams.userId, bucketerParams.experimentKey, groupId);\n          bucketerParams.logger.log(LOG_LEVEL.INFO, notBucketedIntoExperimentOfGroupLogMessage);\n          return null;\n        }\n\n        // Continue bucketing if user is bucketed into specified experiment\n        var bucketedIntoExperimentOfGroupLogMessage = sprintf(LOG_MESSAGES.USER_BUCKETED_INTO_EXPERIMENT_IN_GROUP, MODULE_NAME, bucketerParams.userId, bucketerParams.experimentKey, groupId);\n        bucketerParams.logger.log(LOG_LEVEL.INFO, bucketedIntoExperimentOfGroupLogMessage);\n      }\n    }\n    var bucketingId = sprintf('%s%s', bucketerParams.bucketingId, bucketerParams.experimentId);\n    var bucketValue = module.exports._generateBucketValue(bucketingId);\n\n    var bucketedUserLogMessage = sprintf(LOG_MESSAGES.USER_ASSIGNED_TO_VARIATION_BUCKET, MODULE_NAME, bucketValue, bucketerParams.userId);\n    bucketerParams.logger.log(LOG_LEVEL.DEBUG, bucketedUserLogMessage);\n\n    var entityId = module.exports._findBucket(bucketValue, bucketerParams.trafficAllocationConfig);\n    if (!entityId) {\n      var userHasNoVariationLogMessage = sprintf(LOG_MESSAGES.USER_HAS_NO_VARIATION, MODULE_NAME, bucketerParams.userId, bucketerParams.experimentKey);\n      bucketerParams.logger.log(LOG_LEVEL.DEBUG, userHasNoVariationLogMessage);\n    } else if (!bucketerParams.variationIdMap.hasOwnProperty(entityId)) {\n      var invalidVariationIdLogMessage = sprintf(LOG_MESSAGES.INVALID_VARIATION_ID, MODULE_NAME);\n      bucketerParams.logger.log(LOG_LEVEL.WARNING, invalidVariationIdLogMessage);\n      return null;\n    } else {\n      var variationKey = bucketerParams.variationIdMap[entityId].key;\n      var userInVariationLogMessage = sprintf(LOG_MESSAGES.USER_HAS_VARIATION, MODULE_NAME, bucketerParams.userId, variationKey, bucketerParams.experimentKey);\n      bucketerParams.logger.log(LOG_LEVEL.INFO, userInVariationLogMessage);\n    }\n\n    return entityId;\n  },\n\n  /**\n   * Returns bucketed experiment ID to compare against experiment user is being called into\n   * @param {Object} group        Group that experiment is in\n   * @param {string} bucketingId  Bucketing ID\n   * @param {string} userId       ID of user to be bucketed into experiment\n   * @param {Object} logger       Logger implementation\n   * @return {string} ID of experiment if user is bucketed into experiment within the group, null otherwise\n   */\n  bucketUserIntoExperiment: function(group, bucketingId, userId, logger) {\n    var bucketingKey = sprintf('%s%s', bucketingId, group.id);\n    var bucketValue = module.exports._generateBucketValue(bucketingKey);\n    logger.log(LOG_LEVEL.DEBUG, sprintf(LOG_MESSAGES.USER_ASSIGNED_TO_EXPERIMENT_BUCKET, MODULE_NAME, bucketValue, userId));\n    var trafficAllocationConfig = group.trafficAllocation;\n    var bucketedExperimentId = module.exports._findBucket(bucketValue, trafficAllocationConfig);\n    return bucketedExperimentId;\n  },\n\n  /**\n   * Returns entity ID associated with bucket value\n   * @param  {string}   bucketValue\n   * @param  {Object[]} trafficAllocationConfig\n   * @param  {number}   trafficAllocationConfig[].endOfRange\n   * @param  {number}   trafficAllocationConfig[].entityId\n   * @return {string}   Entity ID for bucketing if bucket value is within traffic allocation boundaries, null otherwise\n   */\n  _findBucket: function(bucketValue, trafficAllocationConfig) {\n    for (var i = 0; i < trafficAllocationConfig.length; i++) {\n      if (bucketValue < trafficAllocationConfig[i].endOfRange) {\n        return trafficAllocationConfig[i].entityId;\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Helper function to generate bucket value in half-closed interval [0, MAX_TRAFFIC_VALUE)\n   * @param  {string} bucketingKey String value for bucketing\n   * @return {string} the generated bucket value\n   * @throws If bucketing value is not a valid string\n   */\n  _generateBucketValue: function(bucketingKey) {\n    try {\n      // NOTE: the mmh library already does cast the hash value as an unsigned 32bit int\n      // https://github.com/perezd/node-murmurhash/blob/master/murmurhash.js#L115\n      var hashValue = murmurhash.v3(bucketingKey, HASH_SEED);\n      var ratio = hashValue / MAX_HASH_VALUE;\n      return parseInt(ratio * MAX_TRAFFIC_VALUE, 10);\n    } catch (ex) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_BUCKETING_ID, MODULE_NAME, bucketingKey, ex.message));\n    }\n  },\n};\n"]},"metadata":{},"sourceType":"script"}
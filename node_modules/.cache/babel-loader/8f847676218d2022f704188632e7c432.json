{"ast":null,"code":"/**\n * Copyright 2016-2019, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar fns = require('../../utils/fns');\n\nvar enums = require('../../utils/enums');\n\nvar sprintf = require('@optimizely/js-sdk-utils').sprintf;\n\nvar configValidator = require('../../utils/config_validator');\n\nvar projectConfigSchema = require('./project_config_schema');\n\nvar EXPERIMENT_RUNNING_STATUS = 'Running';\nvar RESERVED_ATTRIBUTE_PREFIX = '$opt_';\nvar MODULE_NAME = 'PROJECT_CONFIG';\nvar ERROR_MESSAGES = enums.ERROR_MESSAGES;\nvar LOG_MESSAGES = enums.LOG_MESSAGES;\nvar LOG_LEVEL = enums.LOG_LEVEL;\nvar FEATURE_VARIABLE_TYPES = enums.FEATURE_VARIABLE_TYPES;\nmodule.exports = {\n  /**\n   * Creates projectConfig object to be used for quick project property lookup\n   * @param  {Object} datafile JSON datafile representing the project\n   * @return {Object} Object representing project configuration\n   */\n  createProjectConfig: function (datafile) {\n    var projectConfig = fns.cloneDeep(datafile);\n    /*\n     * Conditions of audiences in projectConfig.typedAudiences are not\n     * expected to be string-encoded as they are here in projectConfig.audiences.\n     */\n\n    fns.forEach(projectConfig.audiences, function (audience) {\n      audience.conditions = JSON.parse(audience.conditions);\n    });\n    projectConfig.audiencesById = fns.keyBy(projectConfig.audiences, 'id');\n    fns.assign(projectConfig.audiencesById, fns.keyBy(projectConfig.typedAudiences, 'id'));\n    projectConfig.attributeKeyMap = fns.keyBy(projectConfig.attributes, 'key');\n    projectConfig.eventKeyMap = fns.keyBy(projectConfig.events, 'key');\n    projectConfig.groupIdMap = fns.keyBy(projectConfig.groups, 'id');\n    var experiments;\n    fns.forEach(projectConfig.groupIdMap, function (group, Id) {\n      experiments = fns.cloneDeep(group.experiments);\n      fns.forEach(experiments, function (experiment) {\n        projectConfig.experiments.push(fns.assignIn(experiment, {\n          groupId: Id\n        }));\n      });\n    });\n    projectConfig.rolloutIdMap = fns.keyBy(projectConfig.rollouts || [], 'id');\n    fns.forOwn(projectConfig.rolloutIdMap, function (rollout) {\n      fns.forEach(rollout.experiments || [], function (experiment) {\n        projectConfig.experiments.push(fns.cloneDeep(experiment)); // Creates { <variationKey>: <variation> } map inside of the experiment\n\n        experiment.variationKeyMap = fns.keyBy(experiment.variations, 'key');\n      });\n    });\n    projectConfig.experimentKeyMap = fns.keyBy(projectConfig.experiments, 'key');\n    projectConfig.experimentIdMap = fns.keyBy(projectConfig.experiments, 'id');\n    projectConfig.variationIdMap = {};\n    projectConfig.variationVariableUsageMap = {};\n    fns.forEach(projectConfig.experiments, function (experiment) {\n      // Creates { <variationKey>: <variation> } map inside of the experiment\n      experiment.variationKeyMap = fns.keyBy(experiment.variations, 'key'); // Creates { <variationId>: { key: <variationKey>, id: <variationId> } } mapping for quick lookup\n\n      fns.assignIn(projectConfig.variationIdMap, fns.keyBy(experiment.variations, 'id'));\n      fns.forOwn(experiment.variationKeyMap, function (variation) {\n        if (variation.variables) {\n          projectConfig.variationVariableUsageMap[variation.id] = fns.keyBy(variation.variables, 'id');\n        }\n      });\n    }); // Object containing experiment Ids that exist in any feature\n    // for checking that experiment is a feature experiment or not.\n\n    projectConfig.experimentFeatureMap = {};\n    projectConfig.featureKeyMap = fns.keyBy(projectConfig.featureFlags || [], 'key');\n    fns.forOwn(projectConfig.featureKeyMap, function (feature) {\n      feature.variableKeyMap = fns.keyBy(feature.variables, 'key');\n      fns.forEach(feature.experimentIds || [], function (experimentId) {\n        // Add this experiment in experiment-feature map.\n        if (projectConfig.experimentFeatureMap[experimentId]) {\n          projectConfig.experimentFeatureMap[experimentId].push(feature.id);\n        } else {\n          projectConfig.experimentFeatureMap[experimentId] = [feature.id];\n        }\n\n        var experimentInFeature = projectConfig.experimentIdMap[experimentId]; // Experiments in feature can only belong to one mutex group.\n\n        if (experimentInFeature.groupId && !feature.groupId) {\n          feature.groupId = experimentInFeature.groupId;\n        }\n      });\n    });\n    return projectConfig;\n  },\n\n  /**\n   * Get experiment ID for the provided experiment key\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} experimentKey Experiment key for which ID is to be determined\n   * @return {string} Experiment ID corresponding to the provided experiment key\n   * @throws If experiment key is not in datafile\n   */\n  getExperimentId: function (projectConfig, experimentKey) {\n    var experiment = projectConfig.experimentKeyMap[experimentKey];\n\n    if (fns.isEmpty(experiment)) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_KEY, MODULE_NAME, experimentKey));\n    }\n\n    return experiment.id;\n  },\n\n  /**\n   * Get layer ID for the provided experiment key\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} experimentId Experiment ID for which layer ID is to be determined\n   * @return {string} Layer ID corresponding to the provided experiment key\n   * @throws If experiment key is not in datafile\n   */\n  getLayerId: function (projectConfig, experimentId) {\n    var experiment = projectConfig.experimentIdMap[experimentId];\n\n    if (fns.isEmpty(experiment)) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_ID, MODULE_NAME, experimentId));\n    }\n\n    return experiment.layerId;\n  },\n\n  /**\n   * Get attribute ID for the provided attribute key\n   * @param  {Object}      projectConfig Object representing project configuration\n   * @param  {string}      attributeKey  Attribute key for which ID is to be determined\n   * @param  {Object}      logger\n   * @return {string|null} Attribute ID corresponding to the provided attribute key. Attribute key if it is a reserved attribute.\n   */\n  getAttributeId: function (projectConfig, attributeKey, logger) {\n    var attribute = projectConfig.attributeKeyMap[attributeKey];\n    var hasReservedPrefix = attributeKey.indexOf(RESERVED_ATTRIBUTE_PREFIX) === 0;\n\n    if (attribute) {\n      if (hasReservedPrefix) {\n        logger.log(LOG_LEVEL.WARN, sprintf('Attribute %s unexpectedly has reserved prefix %s; using attribute ID instead of reserved attribute name.', attributeKey, RESERVED_ATTRIBUTE_PREFIX));\n      }\n\n      return attribute.id;\n    } else if (hasReservedPrefix) {\n      return attributeKey;\n    }\n\n    logger.log(LOG_LEVEL.DEBUG, sprintf(ERROR_MESSAGES.UNRECOGNIZED_ATTRIBUTE, MODULE_NAME, attributeKey));\n    return null;\n  },\n\n  /**\n   * Get event ID for the provided\n   * @param  {Object}      projectConfig Object representing project configuration\n   * @param  {string}      eventKey      Event key for which ID is to be determined\n   * @return {string|null} Event ID corresponding to the provided event key\n   */\n  getEventId: function (projectConfig, eventKey) {\n    var event = projectConfig.eventKeyMap[eventKey];\n\n    if (event) {\n      return event.id;\n    }\n\n    return null;\n  },\n\n  /**\n   * Get experiment status for the provided experiment key\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} experimentKey Experiment key for which status is to be determined\n   * @return {string} Experiment status corresponding to the provided experiment key\n   * @throws If experiment key is not in datafile\n   */\n  getExperimentStatus: function (projectConfig, experimentKey) {\n    var experiment = projectConfig.experimentKeyMap[experimentKey];\n\n    if (fns.isEmpty(experiment)) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_KEY, MODULE_NAME, experimentKey));\n    }\n\n    return experiment.status;\n  },\n\n  /**\n   * Returns whether experiment has a status of 'Running'\n   * @param  {Object}  projectConfig Object representing project configuration\n   * @param  {string}  experimentKey Experiment key for which status is to be compared with 'Running'\n   * @return {Boolean}               true if experiment status is set to 'Running', false otherwise\n   */\n  isActive: function (projectConfig, experimentKey) {\n    return module.exports.getExperimentStatus(projectConfig, experimentKey) === EXPERIMENT_RUNNING_STATUS;\n  },\n\n  /**\n   * Determine for given experiment if event is running, which determines whether should be dispatched or not\n   */\n  isRunning: function (projectConfig, experimentKey) {\n    return module.exports.getExperimentStatus(projectConfig, experimentKey) === EXPERIMENT_RUNNING_STATUS;\n  },\n\n  /**\n   * Get audience conditions for the experiment\n   * @param  {Object}         projectConfig Object representing project configuration\n   * @param  {string}         experimentKey Experiment key for which audience conditions are to be determined\n   * @return {Array}          Audience conditions for the experiment - can be an array of audience IDs, or a\n   *                          nested array of conditions\n   *                          Examples: [\"5\", \"6\"], [\"and\", [\"or\", \"1\", \"2\"], \"3\"]\n   * @throws If experiment key is not in datafile\n   */\n  getExperimentAudienceConditions: function (projectConfig, experimentKey) {\n    var experiment = projectConfig.experimentKeyMap[experimentKey];\n\n    if (fns.isEmpty(experiment)) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_KEY, MODULE_NAME, experimentKey));\n    }\n\n    return experiment.audienceConditions || experiment.audienceIds;\n  },\n\n  /**\n   * Get variation key given experiment key and variation ID\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} variationId   ID of the variation\n   * @return {string} Variation key or null if the variation ID is not found\n   */\n  getVariationKeyFromId: function (projectConfig, variationId) {\n    if (projectConfig.variationIdMap.hasOwnProperty(variationId)) {\n      return projectConfig.variationIdMap[variationId].key;\n    }\n\n    return null;\n  },\n\n  /**\n   * Get the variation ID given the experiment key and variation key\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} experimentKey Key of the experiment the variation belongs to\n   * @param  {string} variationKey  The variation key\n   * @return {string} the variation ID\n   */\n  getVariationIdFromExperimentAndVariationKey: function (projectConfig, experimentKey, variationKey) {\n    var experiment = projectConfig.experimentKeyMap[experimentKey];\n\n    if (experiment.variationKeyMap.hasOwnProperty(variationKey)) {\n      return experiment.variationKeyMap[variationKey].id;\n    }\n\n    return null;\n  },\n\n  /**\n   * Get experiment from provided experiment key\n   * @param  {Object} projectConfig  Object representing project configuration\n   * @param  {string} experimentKey  Event key for which experiment IDs are to be retrieved\n   * @return {Object} experiment\n   * @throws If experiment key is not in datafile\n   */\n  getExperimentFromKey: function (projectConfig, experimentKey) {\n    if (projectConfig.experimentKeyMap.hasOwnProperty(experimentKey)) {\n      var experiment = projectConfig.experimentKeyMap[experimentKey];\n\n      if (experiment) {\n        return experiment;\n      }\n    }\n\n    throw new Error(sprintf(ERROR_MESSAGES.EXPERIMENT_KEY_NOT_IN_DATAFILE, MODULE_NAME, experimentKey));\n  },\n\n  /**\n   * Given an experiment key, returns the traffic allocation within that experiment\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} experimentKey Key representing the experiment\n   * @return {Array<Object>}        Traffic allocation for the experiment\n   * @throws If experiment key is not in datafile\n   */\n  getTrafficAllocation: function (projectConfig, experimentKey) {\n    var experiment = projectConfig.experimentKeyMap[experimentKey];\n\n    if (fns.isEmpty(experiment)) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_KEY, MODULE_NAME, experimentKey));\n    }\n\n    return experiment.trafficAllocation;\n  },\n\n  /**\n   * Get experiment from provided experiment id. Log an error if no experiment\n   * exists in the project config with the given ID.\n   * @param  {Object} projectConfig  Object representing project configuration\n   * @param  {string} experimentId  ID of desired experiment object\n   * @return {Object} Experiment object\n   */\n  getExperimentFromId: function (projectConfig, experimentId, logger) {\n    if (projectConfig.experimentIdMap.hasOwnProperty(experimentId)) {\n      var experiment = projectConfig.experimentIdMap[experimentId];\n\n      if (experiment) {\n        return experiment;\n      }\n    }\n\n    logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_ID, MODULE_NAME, experimentId));\n    return null;\n  },\n\n  /**\n   * Get feature from provided feature key. Log an error if no feature exists in\n   * the project config with the given key.\n   * @param {Object} projectConfig\n   * @param {string} featureKey\n   * @param {Object} logger\n   * @return {Object|null} Feature object, or null if no feature with the given\n   * key exists\n   */\n  getFeatureFromKey: function (projectConfig, featureKey, logger) {\n    if (projectConfig.featureKeyMap.hasOwnProperty(featureKey)) {\n      var feature = projectConfig.featureKeyMap[featureKey];\n\n      if (feature) {\n        return feature;\n      }\n    }\n\n    logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.FEATURE_NOT_IN_DATAFILE, MODULE_NAME, featureKey));\n    return null;\n  },\n\n  /**\n   * Get the variable with the given key associated with the feature with the\n   * given key. If the feature key or the variable key are invalid, log an error\n   * message.\n   * @param {Object} projectConfig\n   * @param {string} featureKey\n   * @param {string} variableKey\n   * @param {Object} logger\n   * @return {Object|null} Variable object, or null one or both of the given\n   * feature and variable keys are invalid\n   */\n  getVariableForFeature: function (projectConfig, featureKey, variableKey, logger) {\n    var feature = projectConfig.featureKeyMap[featureKey];\n\n    if (!feature) {\n      logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.FEATURE_NOT_IN_DATAFILE, MODULE_NAME, featureKey));\n      return null;\n    }\n\n    var variable = feature.variableKeyMap[variableKey];\n\n    if (!variable) {\n      logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.VARIABLE_KEY_NOT_IN_DATAFILE, MODULE_NAME, variableKey, featureKey));\n      return null;\n    }\n\n    return variable;\n  },\n\n  /**\n   * Get the value of the given variable for the given variation. If the given\n   * variable has no value for the given variation, return null. Log an error message if the variation is invalid. If the\n   * variable or variation are invalid, return null.\n   * @param {Object} projectConfig\n   * @param {Object} variable\n   * @param {Object} variation\n   * @param {Object} logger\n   * @return {string|null} The value of the given variable for the given\n   * variation, or null if the given variable has no value\n   * for the given variation or if the variation or variable are invalid\n   */\n  getVariableValueForVariation: function (projectConfig, variable, variation, logger) {\n    if (!variable || !variation) {\n      return null;\n    }\n\n    if (!projectConfig.variationVariableUsageMap.hasOwnProperty(variation.id)) {\n      logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.VARIATION_ID_NOT_IN_DATAFILE_NO_EXPERIMENT, MODULE_NAME, variation.id));\n      return null;\n    }\n\n    var variableUsages = projectConfig.variationVariableUsageMap[variation.id];\n    var variableUsage = variableUsages[variable.id];\n    return variableUsage ? variableUsage.value : null;\n  },\n\n  /**\n   * Given a variable value in string form, try to cast it to the argument type.\n   * If the type cast succeeds, return the type casted value, otherwise log an\n   * error and return null.\n   * @param {string} variableValue  Variable value in string form\n   * @param {string} variableType   Type of the variable whose value was passed\n   *                                in the first argument. Must be one of\n   *                                FEATURE_VARIABLE_TYPES in\n   *                                lib/utils/enums/index.js. The return value's\n   *                                type is determined by this argument (boolean\n   *                                for BOOLEAN, number for INTEGER or DOUBLE,\n   *                                and string for STRING).\n   * @param {Object} logger         Logger instance\n   * @returns {*}                   Variable value of the appropriate type, or\n   *                                null if the type cast failed\n   */\n  getTypeCastValue: function (variableValue, variableType, logger) {\n    var castValue;\n\n    switch (variableType) {\n      case FEATURE_VARIABLE_TYPES.BOOLEAN:\n        if (variableValue !== 'true' && variableValue !== 'false') {\n          logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.UNABLE_TO_CAST_VALUE, MODULE_NAME, variableValue, variableType));\n          castValue = null;\n        } else {\n          castValue = variableValue === 'true';\n        }\n\n        break;\n\n      case FEATURE_VARIABLE_TYPES.INTEGER:\n        castValue = parseInt(variableValue, 10);\n\n        if (isNaN(castValue)) {\n          logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.UNABLE_TO_CAST_VALUE, MODULE_NAME, variableValue, variableType));\n          castValue = null;\n        }\n\n        break;\n\n      case FEATURE_VARIABLE_TYPES.DOUBLE:\n        castValue = parseFloat(variableValue);\n\n        if (isNaN(castValue)) {\n          logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.UNABLE_TO_CAST_VALUE, MODULE_NAME, variableValue, variableType));\n          castValue = null;\n        }\n\n        break;\n\n      default:\n        // type is STRING\n        castValue = variableValue;\n        break;\n    }\n\n    return castValue;\n  },\n\n  /**\n   * Returns an object containing all audiences in the project config. Keys are audience IDs\n   * and values are audience objects.\n   * @param projectConfig\n   * @returns {Object}\n   */\n  getAudiencesById: function (projectConfig) {\n    return projectConfig.audiencesById;\n  },\n\n  /**\n   * Returns true if an event with the given key exists in the datafile, and false otherwise\n   * @param {Object} projectConfig\n   * @param {string} eventKey\n   * @returns {boolean}\n   */\n  eventWithKeyExists: function (projectConfig, eventKey) {\n    return projectConfig.eventKeyMap.hasOwnProperty(eventKey);\n  },\n\n  /**\n   *\n   * @param {Object} projectConfig\n   * @param {string} experimentId\n   * @returns {boolean} Returns true if experiment belongs to\n   * any feature, false otherwise.\n   */\n  isFeatureExperiment: function (projectConfig, experimentId) {\n    return projectConfig.experimentFeatureMap.hasOwnProperty(experimentId);\n  },\n\n  /**\n   * Try to create a project config object from the given datafile and\n   * configuration properties.\n   * If successful, return the project config object, otherwise throws an error\n   * @param  {Object} config\n   * @param  {Object} config.datafile\n   * @param  {Object} config.jsonSchemaValidator\n   * @param  {Object} config.logger\n   * @param  {Object} config.skipJSONValidation\n   * @return {Object} Project config object\n   */\n  tryCreatingProjectConfig: function (config) {\n    configValidator.validateDatafile(config.datafile);\n\n    if (config.skipJSONValidation === true) {\n      config.logger.log(LOG_LEVEL.INFO, sprintf(LOG_MESSAGES.SKIPPING_JSON_VALIDATION, MODULE_NAME));\n    } else if (config.jsonSchemaValidator) {\n      config.jsonSchemaValidator.validate(projectConfigSchema, config.datafile);\n      config.logger.log(LOG_LEVEL.INFO, sprintf(LOG_MESSAGES.VALID_DATAFILE, MODULE_NAME));\n    }\n\n    return module.exports.createProjectConfig(config.datafile);\n  }\n};","map":{"version":3,"sources":["/home/abhishek/Music/contentstack-reactjs-ab-testing/node_modules/@optimizely/optimizely-sdk/lib/core/project_config/index.js"],"names":["fns","require","enums","sprintf","configValidator","projectConfigSchema","EXPERIMENT_RUNNING_STATUS","RESERVED_ATTRIBUTE_PREFIX","MODULE_NAME","ERROR_MESSAGES","LOG_MESSAGES","LOG_LEVEL","FEATURE_VARIABLE_TYPES","module","exports","createProjectConfig","datafile","projectConfig","cloneDeep","forEach","audiences","audience","conditions","JSON","parse","audiencesById","keyBy","assign","typedAudiences","attributeKeyMap","attributes","eventKeyMap","events","groupIdMap","groups","experiments","group","Id","experiment","push","assignIn","groupId","rolloutIdMap","rollouts","forOwn","rollout","variationKeyMap","variations","experimentKeyMap","experimentIdMap","variationIdMap","variationVariableUsageMap","variation","variables","id","experimentFeatureMap","featureKeyMap","featureFlags","feature","variableKeyMap","experimentIds","experimentId","experimentInFeature","getExperimentId","experimentKey","isEmpty","Error","INVALID_EXPERIMENT_KEY","getLayerId","INVALID_EXPERIMENT_ID","layerId","getAttributeId","attributeKey","logger","attribute","hasReservedPrefix","indexOf","log","WARN","DEBUG","UNRECOGNIZED_ATTRIBUTE","getEventId","eventKey","event","getExperimentStatus","status","isActive","isRunning","getExperimentAudienceConditions","audienceConditions","audienceIds","getVariationKeyFromId","variationId","hasOwnProperty","key","getVariationIdFromExperimentAndVariationKey","variationKey","getExperimentFromKey","EXPERIMENT_KEY_NOT_IN_DATAFILE","getTrafficAllocation","trafficAllocation","getExperimentFromId","ERROR","getFeatureFromKey","featureKey","FEATURE_NOT_IN_DATAFILE","getVariableForFeature","variableKey","variable","VARIABLE_KEY_NOT_IN_DATAFILE","getVariableValueForVariation","VARIATION_ID_NOT_IN_DATAFILE_NO_EXPERIMENT","variableUsages","variableUsage","value","getTypeCastValue","variableValue","variableType","castValue","BOOLEAN","UNABLE_TO_CAST_VALUE","INTEGER","parseInt","isNaN","DOUBLE","parseFloat","getAudiencesById","eventWithKeyExists","isFeatureExperiment","tryCreatingProjectConfig","config","validateDatafile","skipJSONValidation","INFO","SKIPPING_JSON_VALIDATION","jsonSchemaValidator","validate","VALID_DATAFILE"],"mappings":"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","sourcesContent":["/**\n * Copyright 2016-2019, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar fns = require('../../utils/fns');\nvar enums = require('../../utils/enums');\nvar sprintf = require('@optimizely/js-sdk-utils').sprintf;\nvar configValidator = require('../../utils/config_validator');\nvar projectConfigSchema = require('./project_config_schema');\n\nvar EXPERIMENT_RUNNING_STATUS = 'Running';\nvar RESERVED_ATTRIBUTE_PREFIX = '$opt_';\nvar MODULE_NAME = 'PROJECT_CONFIG';\n\nvar ERROR_MESSAGES = enums.ERROR_MESSAGES;\nvar LOG_MESSAGES = enums.LOG_MESSAGES;\nvar LOG_LEVEL = enums.LOG_LEVEL;\nvar FEATURE_VARIABLE_TYPES = enums.FEATURE_VARIABLE_TYPES;\n\nmodule.exports = {\n  /**\n   * Creates projectConfig object to be used for quick project property lookup\n   * @param  {Object} datafile JSON datafile representing the project\n   * @return {Object} Object representing project configuration\n   */\n  createProjectConfig: function(datafile) {\n    var projectConfig = fns.cloneDeep(datafile);\n\n    /*\n     * Conditions of audiences in projectConfig.typedAudiences are not\n     * expected to be string-encoded as they are here in projectConfig.audiences.\n     */\n    fns.forEach(projectConfig.audiences, function(audience) {\n      audience.conditions = JSON.parse(audience.conditions);\n    });\n    projectConfig.audiencesById = fns.keyBy(projectConfig.audiences, 'id');\n    fns.assign(projectConfig.audiencesById, fns.keyBy(projectConfig.typedAudiences, 'id'));\n\n    projectConfig.attributeKeyMap = fns.keyBy(projectConfig.attributes, 'key');\n    projectConfig.eventKeyMap = fns.keyBy(projectConfig.events, 'key');\n    projectConfig.groupIdMap = fns.keyBy(projectConfig.groups, 'id');\n\n    var experiments;\n    fns.forEach(projectConfig.groupIdMap, function(group, Id) {\n      experiments = fns.cloneDeep(group.experiments);\n      fns.forEach(experiments, function(experiment) {\n        projectConfig.experiments.push(fns.assignIn(experiment, {groupId: Id}));\n      });\n    });\n\n    projectConfig.rolloutIdMap = fns.keyBy(projectConfig.rollouts || [], 'id');\n    fns.forOwn(projectConfig.rolloutIdMap, function(rollout) {\n      fns.forEach(rollout.experiments || [], function(experiment) {\n        projectConfig.experiments.push(fns.cloneDeep(experiment));\n        // Creates { <variationKey>: <variation> } map inside of the experiment\n        experiment.variationKeyMap = fns.keyBy(experiment.variations, 'key');\n      });\n    });\n\n    projectConfig.experimentKeyMap = fns.keyBy(projectConfig.experiments, 'key');\n    projectConfig.experimentIdMap = fns.keyBy(projectConfig.experiments, 'id');\n\n    projectConfig.variationIdMap = {};\n    projectConfig.variationVariableUsageMap = {};\n    fns.forEach(projectConfig.experiments, function(experiment) {\n      // Creates { <variationKey>: <variation> } map inside of the experiment\n      experiment.variationKeyMap = fns.keyBy(experiment.variations, 'key');\n\n      // Creates { <variationId>: { key: <variationKey>, id: <variationId> } } mapping for quick lookup\n      fns.assignIn(projectConfig.variationIdMap, fns.keyBy(experiment.variations, 'id'));\n\n      fns.forOwn(experiment.variationKeyMap, function(variation) {\n        if (variation.variables) {\n          projectConfig.variationVariableUsageMap[variation.id] = fns.keyBy(variation.variables, 'id');\n        }\n      });\n    });\n\n    // Object containing experiment Ids that exist in any feature\n    // for checking that experiment is a feature experiment or not.\n    projectConfig.experimentFeatureMap = {};\n\n    projectConfig.featureKeyMap = fns.keyBy(projectConfig.featureFlags || [], 'key');\n    fns.forOwn(projectConfig.featureKeyMap, function(feature) {\n      feature.variableKeyMap = fns.keyBy(feature.variables, 'key');\n      fns.forEach(feature.experimentIds || [], function(experimentId) {\n        // Add this experiment in experiment-feature map.\n        if (projectConfig.experimentFeatureMap[experimentId]) {\n          projectConfig.experimentFeatureMap[experimentId].push(feature.id);\n        } else {\n          projectConfig.experimentFeatureMap[experimentId] = [feature.id];\n        }\n\n        var experimentInFeature = projectConfig.experimentIdMap[experimentId];\n        // Experiments in feature can only belong to one mutex group.\n        if (experimentInFeature.groupId && !feature.groupId) {\n          feature.groupId = experimentInFeature.groupId;\n        }\n      });\n    });\n\n    return projectConfig;\n  },\n\n  /**\n   * Get experiment ID for the provided experiment key\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} experimentKey Experiment key for which ID is to be determined\n   * @return {string} Experiment ID corresponding to the provided experiment key\n   * @throws If experiment key is not in datafile\n   */\n  getExperimentId: function(projectConfig, experimentKey) {\n    var experiment = projectConfig.experimentKeyMap[experimentKey];\n    if (fns.isEmpty(experiment)) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_KEY, MODULE_NAME, experimentKey));\n    }\n    return experiment.id;\n  },\n\n  /**\n   * Get layer ID for the provided experiment key\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} experimentId Experiment ID for which layer ID is to be determined\n   * @return {string} Layer ID corresponding to the provided experiment key\n   * @throws If experiment key is not in datafile\n   */\n  getLayerId: function(projectConfig, experimentId) {\n    var experiment = projectConfig.experimentIdMap[experimentId];\n    if (fns.isEmpty(experiment)) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_ID, MODULE_NAME, experimentId));\n    }\n    return experiment.layerId;\n  },\n\n  /**\n   * Get attribute ID for the provided attribute key\n   * @param  {Object}      projectConfig Object representing project configuration\n   * @param  {string}      attributeKey  Attribute key for which ID is to be determined\n   * @param  {Object}      logger\n   * @return {string|null} Attribute ID corresponding to the provided attribute key. Attribute key if it is a reserved attribute.\n   */\n  getAttributeId: function(projectConfig, attributeKey, logger) {\n    var attribute = projectConfig.attributeKeyMap[attributeKey];\n    var hasReservedPrefix = attributeKey.indexOf(RESERVED_ATTRIBUTE_PREFIX) === 0;\n    if (attribute) {\n      if (hasReservedPrefix) {\n        logger.log(LOG_LEVEL.WARN,\n                   sprintf('Attribute %s unexpectedly has reserved prefix %s; using attribute ID instead of reserved attribute name.', attributeKey, RESERVED_ATTRIBUTE_PREFIX));\n      }\n      return attribute.id;\n    } else if (hasReservedPrefix) {\n      return attributeKey;\n    }\n\n    logger.log(LOG_LEVEL.DEBUG, sprintf(ERROR_MESSAGES.UNRECOGNIZED_ATTRIBUTE, MODULE_NAME, attributeKey));\n    return null;\n  },\n\n  /**\n   * Get event ID for the provided\n   * @param  {Object}      projectConfig Object representing project configuration\n   * @param  {string}      eventKey      Event key for which ID is to be determined\n   * @return {string|null} Event ID corresponding to the provided event key\n   */\n  getEventId: function(projectConfig, eventKey) {\n    var event = projectConfig.eventKeyMap[eventKey];\n    if (event) {\n      return event.id;\n    }\n    return null;\n  },\n\n  /**\n   * Get experiment status for the provided experiment key\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} experimentKey Experiment key for which status is to be determined\n   * @return {string} Experiment status corresponding to the provided experiment key\n   * @throws If experiment key is not in datafile\n   */\n  getExperimentStatus: function(projectConfig, experimentKey) {\n    var experiment = projectConfig.experimentKeyMap[experimentKey];\n    if (fns.isEmpty(experiment)) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_KEY, MODULE_NAME, experimentKey));\n    }\n    return experiment.status;\n  },\n\n  /**\n   * Returns whether experiment has a status of 'Running'\n   * @param  {Object}  projectConfig Object representing project configuration\n   * @param  {string}  experimentKey Experiment key for which status is to be compared with 'Running'\n   * @return {Boolean}               true if experiment status is set to 'Running', false otherwise\n   */\n  isActive: function(projectConfig, experimentKey) {\n    return module.exports.getExperimentStatus(projectConfig, experimentKey) === EXPERIMENT_RUNNING_STATUS;\n  },\n\n  /**\n   * Determine for given experiment if event is running, which determines whether should be dispatched or not\n   */\n  isRunning: function(projectConfig, experimentKey) {\n    return module.exports.getExperimentStatus(projectConfig, experimentKey) === EXPERIMENT_RUNNING_STATUS;\n  },\n\n  /**\n   * Get audience conditions for the experiment\n   * @param  {Object}         projectConfig Object representing project configuration\n   * @param  {string}         experimentKey Experiment key for which audience conditions are to be determined\n   * @return {Array}          Audience conditions for the experiment - can be an array of audience IDs, or a\n   *                          nested array of conditions\n   *                          Examples: [\"5\", \"6\"], [\"and\", [\"or\", \"1\", \"2\"], \"3\"]\n   * @throws If experiment key is not in datafile\n   */\n  getExperimentAudienceConditions: function(projectConfig, experimentKey) {\n    var experiment = projectConfig.experimentKeyMap[experimentKey];\n    if (fns.isEmpty(experiment)) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_KEY, MODULE_NAME, experimentKey));\n    }\n\n    return experiment.audienceConditions || experiment.audienceIds;\n  },\n\n  /**\n   * Get variation key given experiment key and variation ID\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} variationId   ID of the variation\n   * @return {string} Variation key or null if the variation ID is not found\n   */\n  getVariationKeyFromId: function(projectConfig, variationId) {\n    if (projectConfig.variationIdMap.hasOwnProperty(variationId)) {\n      return projectConfig.variationIdMap[variationId].key;\n    }\n    return null;\n  },\n\n  /**\n   * Get the variation ID given the experiment key and variation key\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} experimentKey Key of the experiment the variation belongs to\n   * @param  {string} variationKey  The variation key\n   * @return {string} the variation ID\n   */\n  getVariationIdFromExperimentAndVariationKey: function(projectConfig, experimentKey, variationKey) {\n    var experiment = projectConfig.experimentKeyMap[experimentKey];\n    if (experiment.variationKeyMap.hasOwnProperty(variationKey)) {\n      return experiment.variationKeyMap[variationKey].id;\n    }\n    return null;\n  },\n\n  /**\n   * Get experiment from provided experiment key\n   * @param  {Object} projectConfig  Object representing project configuration\n   * @param  {string} experimentKey  Event key for which experiment IDs are to be retrieved\n   * @return {Object} experiment\n   * @throws If experiment key is not in datafile\n   */\n  getExperimentFromKey: function(projectConfig, experimentKey) {\n    if (projectConfig.experimentKeyMap.hasOwnProperty(experimentKey)) {\n      var experiment = projectConfig.experimentKeyMap[experimentKey];\n      if (experiment) {\n        return experiment;\n      }\n    }\n\n    throw new Error(sprintf(ERROR_MESSAGES.EXPERIMENT_KEY_NOT_IN_DATAFILE, MODULE_NAME, experimentKey));\n  },\n\n  /**\n   * Given an experiment key, returns the traffic allocation within that experiment\n   * @param  {Object} projectConfig Object representing project configuration\n   * @param  {string} experimentKey Key representing the experiment\n   * @return {Array<Object>}        Traffic allocation for the experiment\n   * @throws If experiment key is not in datafile\n   */\n  getTrafficAllocation: function(projectConfig, experimentKey) {\n    var experiment = projectConfig.experimentKeyMap[experimentKey];\n    if (fns.isEmpty(experiment)) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_KEY, MODULE_NAME, experimentKey));\n    }\n    return experiment.trafficAllocation;\n  },\n\n  /**\n   * Get experiment from provided experiment id. Log an error if no experiment\n   * exists in the project config with the given ID.\n   * @param  {Object} projectConfig  Object representing project configuration\n   * @param  {string} experimentId  ID of desired experiment object\n   * @return {Object} Experiment object\n   */\n  getExperimentFromId: function(projectConfig, experimentId, logger) {\n    if (projectConfig.experimentIdMap.hasOwnProperty(experimentId)) {\n      var experiment = projectConfig.experimentIdMap[experimentId];\n      if (experiment) {\n        return experiment;\n      }\n    }\n\n    logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_ID, MODULE_NAME, experimentId));\n    return null;\n  },\n\n  /**\n   * Get feature from provided feature key. Log an error if no feature exists in\n   * the project config with the given key.\n   * @param {Object} projectConfig\n   * @param {string} featureKey\n   * @param {Object} logger\n   * @return {Object|null} Feature object, or null if no feature with the given\n   * key exists\n   */\n  getFeatureFromKey: function(projectConfig, featureKey, logger) {\n    if (projectConfig.featureKeyMap.hasOwnProperty(featureKey)) {\n      var feature = projectConfig.featureKeyMap[featureKey];\n      if (feature) {\n        return feature;\n      }\n    }\n\n    logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.FEATURE_NOT_IN_DATAFILE, MODULE_NAME, featureKey));\n    return null;\n  },\n\n  /**\n   * Get the variable with the given key associated with the feature with the\n   * given key. If the feature key or the variable key are invalid, log an error\n   * message.\n   * @param {Object} projectConfig\n   * @param {string} featureKey\n   * @param {string} variableKey\n   * @param {Object} logger\n   * @return {Object|null} Variable object, or null one or both of the given\n   * feature and variable keys are invalid\n   */\n  getVariableForFeature: function(projectConfig, featureKey, variableKey, logger) {\n    var feature = projectConfig.featureKeyMap[featureKey];\n    if (!feature) {\n      logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.FEATURE_NOT_IN_DATAFILE, MODULE_NAME, featureKey));\n      return null;\n    }\n\n    var variable = feature.variableKeyMap[variableKey];\n    if (!variable) {\n      logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.VARIABLE_KEY_NOT_IN_DATAFILE, MODULE_NAME, variableKey, featureKey));\n      return null;\n    }\n\n    return variable;\n  },\n\n  /**\n   * Get the value of the given variable for the given variation. If the given\n   * variable has no value for the given variation, return null. Log an error message if the variation is invalid. If the\n   * variable or variation are invalid, return null.\n   * @param {Object} projectConfig\n   * @param {Object} variable\n   * @param {Object} variation\n   * @param {Object} logger\n   * @return {string|null} The value of the given variable for the given\n   * variation, or null if the given variable has no value\n   * for the given variation or if the variation or variable are invalid\n   */\n  getVariableValueForVariation: function(projectConfig, variable, variation, logger) {\n    if (!variable || !variation) {\n      return null;\n    }\n\n    if (!projectConfig.variationVariableUsageMap.hasOwnProperty(variation.id)) {\n      logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.VARIATION_ID_NOT_IN_DATAFILE_NO_EXPERIMENT, MODULE_NAME, variation.id));\n      return null;\n    }\n\n    var variableUsages = projectConfig.variationVariableUsageMap[variation.id];\n    var variableUsage = variableUsages[variable.id];\n\n    return variableUsage ? variableUsage.value : null;\n  },\n\n  /**\n   * Given a variable value in string form, try to cast it to the argument type.\n   * If the type cast succeeds, return the type casted value, otherwise log an\n   * error and return null.\n   * @param {string} variableValue  Variable value in string form\n   * @param {string} variableType   Type of the variable whose value was passed\n   *                                in the first argument. Must be one of\n   *                                FEATURE_VARIABLE_TYPES in\n   *                                lib/utils/enums/index.js. The return value's\n   *                                type is determined by this argument (boolean\n   *                                for BOOLEAN, number for INTEGER or DOUBLE,\n   *                                and string for STRING).\n   * @param {Object} logger         Logger instance\n   * @returns {*}                   Variable value of the appropriate type, or\n   *                                null if the type cast failed\n   */\n  getTypeCastValue: function(variableValue, variableType, logger) {\n    var castValue;\n\n    switch (variableType) {\n      case FEATURE_VARIABLE_TYPES.BOOLEAN:\n        if (variableValue !== 'true' && variableValue !== 'false') {\n          logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.UNABLE_TO_CAST_VALUE, MODULE_NAME, variableValue, variableType));\n          castValue = null;\n        } else {\n          castValue = variableValue === 'true';\n        }\n        break;\n\n      case FEATURE_VARIABLE_TYPES.INTEGER:\n        castValue = parseInt(variableValue, 10);\n        if (isNaN(castValue)) {\n          logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.UNABLE_TO_CAST_VALUE, MODULE_NAME, variableValue, variableType));\n          castValue = null;\n        }\n        break;\n\n      case FEATURE_VARIABLE_TYPES.DOUBLE:\n        castValue = parseFloat(variableValue);\n        if (isNaN(castValue)) {\n          logger.log(LOG_LEVEL.ERROR, sprintf(ERROR_MESSAGES.UNABLE_TO_CAST_VALUE, MODULE_NAME, variableValue, variableType));\n          castValue = null;\n        }\n        break;\n\n      default: // type is STRING\n        castValue = variableValue;\n        break;\n    }\n\n    return castValue;\n  },\n\n  /**\n   * Returns an object containing all audiences in the project config. Keys are audience IDs\n   * and values are audience objects.\n   * @param projectConfig\n   * @returns {Object}\n   */\n  getAudiencesById: function(projectConfig) {\n    return projectConfig.audiencesById;\n  },\n\n  /**\n   * Returns true if an event with the given key exists in the datafile, and false otherwise\n   * @param {Object} projectConfig\n   * @param {string} eventKey\n   * @returns {boolean}\n   */\n  eventWithKeyExists: function(projectConfig, eventKey) {\n    return projectConfig.eventKeyMap.hasOwnProperty(eventKey);\n  },\n\n  /**\n   *\n   * @param {Object} projectConfig\n   * @param {string} experimentId\n   * @returns {boolean} Returns true if experiment belongs to\n   * any feature, false otherwise.\n   */\n  isFeatureExperiment: function(projectConfig, experimentId) {\n    return projectConfig.experimentFeatureMap.hasOwnProperty(experimentId);\n  },\n\n  /**\n   * Try to create a project config object from the given datafile and\n   * configuration properties.\n   * If successful, return the project config object, otherwise throws an error\n   * @param  {Object} config\n   * @param  {Object} config.datafile\n   * @param  {Object} config.jsonSchemaValidator\n   * @param  {Object} config.logger\n   * @param  {Object} config.skipJSONValidation\n   * @return {Object} Project config object\n   */\n  tryCreatingProjectConfig: function(config) {\n    configValidator.validateDatafile(config.datafile);\n    if (config.skipJSONValidation === true) {\n      config.logger.log(LOG_LEVEL.INFO, sprintf(LOG_MESSAGES.SKIPPING_JSON_VALIDATION, MODULE_NAME));\n    } else if (config.jsonSchemaValidator) {\n      config.jsonSchemaValidator.validate(projectConfigSchema, config.datafile);\n      config.logger.log(LOG_LEVEL.INFO, sprintf(LOG_MESSAGES.VALID_DATAFILE, MODULE_NAME));\n    }\n    return module.exports.createProjectConfig(config.datafile);\n  },\n};\n"]},"metadata":{},"sourceType":"script"}
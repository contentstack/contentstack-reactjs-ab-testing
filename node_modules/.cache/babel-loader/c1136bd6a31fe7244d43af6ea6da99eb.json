{"ast":null,"code":"/**\n * Copyright 2017, 2019 Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar enums = require('../../utils/enums');\n\nvar fns = require('../../utils/fns');\n\nvar sprintf = require('@optimizely/js-sdk-utils').sprintf;\n\nvar LOG_LEVEL = enums.LOG_LEVEL;\nvar LOG_MESSAGES = enums.LOG_MESSAGES;\nvar MODULE_NAME = 'NOTIFICATION_CENTER';\n/**\n * NotificationCenter allows registration and triggering of callback functions using\n * notification event types defined in NOTIFICATION_TYPES of utils/enums/index.js:\n * - ACTIVATE: An impression event will be sent to Optimizely.\n * - TRACK a conversion event will be sent to Optimizely\n * @constructor\n * @param {Object} options\n * @param {Object} options.logger An instance of a logger to log messages with\n * @param {object} options.errorHandler An instance of errorHandler to handle any unexpected error\n * @returns {Object}\n */\n\nfunction NotificationCenter(options) {\n  this.logger = options.logger;\n  this.errorHandler = options.errorHandler;\n  this.__notificationListeners = {};\n  fns.forOwn(enums.NOTIFICATION_TYPES, function (notificationTypeEnum) {\n    this.__notificationListeners[notificationTypeEnum] = [];\n  }.bind(this));\n  this.__listenerId = 1;\n}\n/**\n * Add a notification callback to the notification center\n * @param {string} notificationType One of the values from NOTIFICATION_TYPES in utils/enums/index.js\n * @param {Function} callback Function that will be called when the event is triggered\n * @returns {number} If the callback was successfully added, returns a listener ID which can be used\n * to remove the callback by calling removeNotificationListener. The ID is a number greater than 0.\n * If there was an error and the listener was not added, addNotificationListener returns -1. This\n * can happen if the first argument is not a valid notification type, or if the same callback\n * function was already added as a listener by a prior call to this function.\n */\n\n\nNotificationCenter.prototype.addNotificationListener = function (notificationType, callback) {\n  try {\n    var isNotificationTypeValid = fns.values(enums.NOTIFICATION_TYPES).indexOf(notificationType) > -1;\n\n    if (!isNotificationTypeValid) {\n      return -1;\n    }\n\n    if (!this.__notificationListeners[notificationType]) {\n      this.__notificationListeners[notificationType] = [];\n    }\n\n    var callbackAlreadyAdded = false;\n    fns.forEach(this.__notificationListeners[notificationType], function (listenerEntry) {\n      if (listenerEntry.callback === callback) {\n        callbackAlreadyAdded = true;\n        return false;\n      }\n    });\n\n    if (callbackAlreadyAdded) {\n      return -1;\n    }\n\n    this.__notificationListeners[notificationType].push({\n      id: this.__listenerId,\n      callback: callback\n    });\n\n    var returnId = this.__listenerId;\n    this.__listenerId += 1;\n    return returnId;\n  } catch (e) {\n    this.logger.log(LOG_LEVEL.ERROR, e.message);\n    this.errorHandler.handleError(e);\n    return -1;\n  }\n};\n/**\n * Remove a previously added notification callback\n * @param {number} listenerId ID of listener to be removed\n * @returns {boolean} Returns true if the listener was found and removed, and false\n * otherwise.\n */\n\n\nNotificationCenter.prototype.removeNotificationListener = function (listenerId) {\n  try {\n    var indexToRemove;\n    var typeToRemove;\n    fns.forOwn(this.__notificationListeners, function (listenersForType, notificationType) {\n      fns.forEach(listenersForType, function (listenerEntry, i) {\n        if (listenerEntry.id === listenerId) {\n          indexToRemove = i;\n          typeToRemove = notificationType;\n          return false;\n        }\n      });\n\n      if (indexToRemove !== undefined && typeToRemove !== undefined) {\n        return false;\n      }\n    });\n\n    if (indexToRemove !== undefined && typeToRemove !== undefined) {\n      this.__notificationListeners[typeToRemove].splice(indexToRemove, 1);\n\n      return true;\n    }\n  } catch (e) {\n    this.logger.log(LOG_LEVEL.ERROR, e.message);\n    this.errorHandler.handleError(e);\n  }\n\n  return false;\n};\n/**\n * Removes all previously added notification listeners, for all notification types\n */\n\n\nNotificationCenter.prototype.clearAllNotificationListeners = function () {\n  try {\n    fns.forOwn(enums.NOTIFICATION_TYPES, function (notificationTypeEnum) {\n      this.__notificationListeners[notificationTypeEnum] = [];\n    }.bind(this));\n  } catch (e) {\n    this.logger.log(LOG_LEVEL.ERROR, e.message);\n    this.errorHandler.handleError(e);\n  }\n};\n/**\n * Remove all previously added notification listeners for the argument type\n * @param {string} notificationType One of enums.NOTIFICATION_TYPES\n */\n\n\nNotificationCenter.prototype.clearNotificationListeners = function (notificationType) {\n  try {\n    this.__notificationListeners[notificationType] = [];\n  } catch (e) {\n    this.logger.log(LOG_LEVEL.ERROR, e.message);\n    this.errorHandler.handleError(e);\n  }\n};\n/**\n * Fires notifications for the argument type. All registered callbacks for this type will be\n * called. The notificationData object will be passed on to callbacks called.\n * @param {string} notificationType One of enums.NOTIFICATION_TYPES\n * @param {Object} notificationData Will be passed to callbacks called\n */\n\n\nNotificationCenter.prototype.sendNotifications = function (notificationType, notificationData) {\n  try {\n    fns.forEach(this.__notificationListeners[notificationType], function (listenerEntry) {\n      var callback = listenerEntry.callback;\n\n      try {\n        callback(notificationData);\n      } catch (ex) {\n        this.logger.log(LOG_LEVEL.ERROR, sprintf(LOG_MESSAGES.NOTIFICATION_LISTENER_EXCEPTION, MODULE_NAME, notificationType, ex.message));\n      }\n    }.bind(this));\n  } catch (e) {\n    this.logger.log(LOG_LEVEL.ERROR, e.message);\n    this.errorHandler.handleError(e);\n  }\n};\n\nmodule.exports = {\n  /**\n   * Create an instance of NotificationCenter\n   * @param {Object} options\n   * @param {Object} options.logger An instance of a logger to log messages with\n   * @returns {Object} An instance of NotificationCenter\n   */\n  createNotificationCenter: function (options) {\n    return new NotificationCenter(options);\n  }\n};","map":{"version":3,"sources":["/home/abhishek/Music/contentstack-reactjs-ab-testing/node_modules/@optimizely/optimizely-sdk/lib/core/notification_center/index.js"],"names":["enums","require","fns","sprintf","LOG_LEVEL","LOG_MESSAGES","MODULE_NAME","NotificationCenter","options","logger","errorHandler","__notificationListeners","forOwn","NOTIFICATION_TYPES","notificationTypeEnum","bind","__listenerId","prototype","addNotificationListener","notificationType","callback","isNotificationTypeValid","values","indexOf","callbackAlreadyAdded","forEach","listenerEntry","push","id","returnId","e","log","ERROR","message","handleError","removeNotificationListener","listenerId","indexToRemove","typeToRemove","listenersForType","i","undefined","splice","clearAllNotificationListeners","clearNotificationListeners","sendNotifications","notificationData","ex","NOTIFICATION_LISTENER_EXCEPTION","module","exports","createNotificationCenter"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017, 2019 Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar enums = require('../../utils/enums');\nvar fns = require('../../utils/fns');\nvar sprintf = require('@optimizely/js-sdk-utils').sprintf;\n\nvar LOG_LEVEL = enums.LOG_LEVEL;\nvar LOG_MESSAGES = enums.LOG_MESSAGES;\nvar MODULE_NAME = 'NOTIFICATION_CENTER';\n\n/**\n * NotificationCenter allows registration and triggering of callback functions using\n * notification event types defined in NOTIFICATION_TYPES of utils/enums/index.js:\n * - ACTIVATE: An impression event will be sent to Optimizely.\n * - TRACK a conversion event will be sent to Optimizely\n * @constructor\n * @param {Object} options\n * @param {Object} options.logger An instance of a logger to log messages with\n * @param {object} options.errorHandler An instance of errorHandler to handle any unexpected error\n * @returns {Object}\n */\nfunction NotificationCenter(options) {\n  this.logger = options.logger;\n  this.errorHandler = options.errorHandler;\n  this.__notificationListeners = {};\n  fns.forOwn(enums.NOTIFICATION_TYPES, function(notificationTypeEnum) {\n    this.__notificationListeners[notificationTypeEnum] = [];\n  }.bind(this));\n  this.__listenerId = 1;\n}\n\n/**\n * Add a notification callback to the notification center\n * @param {string} notificationType One of the values from NOTIFICATION_TYPES in utils/enums/index.js\n * @param {Function} callback Function that will be called when the event is triggered\n * @returns {number} If the callback was successfully added, returns a listener ID which can be used\n * to remove the callback by calling removeNotificationListener. The ID is a number greater than 0.\n * If there was an error and the listener was not added, addNotificationListener returns -1. This\n * can happen if the first argument is not a valid notification type, or if the same callback\n * function was already added as a listener by a prior call to this function.\n */\nNotificationCenter.prototype.addNotificationListener = function (notificationType, callback) {\n  try {\n    var isNotificationTypeValid = fns.values(enums.NOTIFICATION_TYPES)\n      .indexOf(notificationType) > -1;\n    if (!isNotificationTypeValid) {\n      return -1;\n    }\n\n    if (!this.__notificationListeners[notificationType]) {\n      this.__notificationListeners[notificationType] = [];\n    }\n\n    var callbackAlreadyAdded = false;\n    fns.forEach(this.__notificationListeners[notificationType], function (listenerEntry) {\n      if (listenerEntry.callback === callback) {\n        callbackAlreadyAdded = true;\n        return false;\n      }\n    });\n    if (callbackAlreadyAdded) {\n      return -1;\n    }\n\n    this.__notificationListeners[notificationType].push({\n      id: this.__listenerId,\n      callback: callback,\n    });\n\n    var returnId = this.__listenerId;\n    this.__listenerId += 1;\n    return returnId;\n  } catch (e) {\n    this.logger.log(LOG_LEVEL.ERROR, e.message);\n    this.errorHandler.handleError(e);\n    return -1;\n  }\n};\n\n/**\n * Remove a previously added notification callback\n * @param {number} listenerId ID of listener to be removed\n * @returns {boolean} Returns true if the listener was found and removed, and false\n * otherwise.\n */\nNotificationCenter.prototype.removeNotificationListener = function (listenerId) {\n  try {\n    var indexToRemove;\n    var typeToRemove;\n    fns.forOwn(this.__notificationListeners, function (listenersForType, notificationType) {\n      fns.forEach(listenersForType, function (listenerEntry, i) {\n        if (listenerEntry.id === listenerId) {\n          indexToRemove = i;\n          typeToRemove = notificationType;\n          return false;\n        }\n      });\n      if (indexToRemove !== undefined && typeToRemove !== undefined) {\n        return false;\n      }\n    });\n\n    if (indexToRemove !== undefined && typeToRemove !== undefined) {\n      this.__notificationListeners[typeToRemove].splice(indexToRemove, 1);\n      return true;\n    }\n  } catch (e) {\n    this.logger.log(LOG_LEVEL.ERROR, e.message);\n    this.errorHandler.handleError(e);\n  }\n  return false;\n};\n\n/**\n * Removes all previously added notification listeners, for all notification types\n */\nNotificationCenter.prototype.clearAllNotificationListeners = function () {\n  try{\n    fns.forOwn(enums.NOTIFICATION_TYPES, function (notificationTypeEnum) {\n      this.__notificationListeners[notificationTypeEnum] = [];\n    }.bind(this));\n  } catch (e) {\n    this.logger.log(LOG_LEVEL.ERROR, e.message);\n    this.errorHandler.handleError(e);\n  }\n};\n\n/**\n * Remove all previously added notification listeners for the argument type\n * @param {string} notificationType One of enums.NOTIFICATION_TYPES\n */\nNotificationCenter.prototype.clearNotificationListeners = function (notificationType) {\n  try {\n    this.__notificationListeners[notificationType] = [];\n  } catch (e) {\n    this.logger.log(LOG_LEVEL.ERROR, e.message);\n    this.errorHandler.handleError(e);\n  }\n};\n\n/**\n * Fires notifications for the argument type. All registered callbacks for this type will be\n * called. The notificationData object will be passed on to callbacks called.\n * @param {string} notificationType One of enums.NOTIFICATION_TYPES\n * @param {Object} notificationData Will be passed to callbacks called\n */\nNotificationCenter.prototype.sendNotifications = function (notificationType, notificationData) {\n  try {\n    fns.forEach(this.__notificationListeners[notificationType], function (listenerEntry) {\n      var callback = listenerEntry.callback;\n      try {\n        callback(notificationData);\n      } catch (ex) {\n        this.logger.log(LOG_LEVEL.ERROR, sprintf(LOG_MESSAGES.NOTIFICATION_LISTENER_EXCEPTION, MODULE_NAME, notificationType, ex.message));\n      }\n    }.bind(this));\n  } catch (e) {\n    this.logger.log(LOG_LEVEL.ERROR, e.message);\n    this.errorHandler.handleError(e);\n  }\n};\n\nmodule.exports = {\n  /**\n   * Create an instance of NotificationCenter\n   * @param {Object} options\n   * @param {Object} options.logger An instance of a logger to log messages with\n   * @returns {Object} An instance of NotificationCenter\n   */\n  createNotificationCenter: function(options) {\n    return new NotificationCenter(options);\n  },\n};\n"]},"metadata":{},"sourceType":"script"}
/**
 * Copyright 2019, Optimizely
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Managed } from './managed';
export declare type EventQueueSink<K> = (buffer: K[]) => Promise<any>;
export interface EventQueue<K> extends Managed {
    enqueue(event: K): void;
}
export interface EventQueueFactory<K> {
    createEventQueue(config: {
        sink: EventQueueSink<K>;
        flushInterval: number;
        maxQueueSize: number;
    }): EventQueue<K>;
}
declare class Timer {
    private timeout;
    private callback;
    private timeoutId?;
    constructor({ timeout, callback }: {
        timeout: number;
        callback: () => void;
    });
    start(): void;
    refresh(): void;
    stop(): void;
}
export declare class SingleEventQueue<K> implements EventQueue<K> {
    private sink;
    constructor({ sink }: {
        sink: EventQueueSink<K>;
    });
    start(): void;
    stop(): Promise<any>;
    enqueue(event: K): void;
}
export declare class DefaultEventQueue<K> implements EventQueue<K> {
    timer: Timer;
    private buffer;
    private maxQueueSize;
    private sink;
    private batchComparator;
    private started;
    constructor({ flushInterval, maxQueueSize, sink, batchComparator, }: {
        flushInterval: number;
        maxQueueSize: number;
        sink: EventQueueSink<K>;
        batchComparator: (eventA: K, eventB: K) => boolean;
    });
    start(): void;
    stop(): Promise<any>;
    enqueue(event: K): void;
    flush(): void;
}
export {};

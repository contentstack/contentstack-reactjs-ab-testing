"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("./events");
var eventQueue_1 = require("./eventQueue");
var js_sdk_logging_1 = require("@optimizely/js-sdk-logging");
var js_sdk_utils_1 = require("@optimizely/js-sdk-utils");
var logger = js_sdk_logging_1.getLogger('EventProcessor');
var DEFAULT_FLUSH_INTERVAL = 30000; // Unit is ms - default flush interval is 30s
var DEFAULT_MAX_QUEUE_SIZE = 10;
var AbstractEventProcessor = /** @class */ (function () {
    function AbstractEventProcessor(_a) {
        var dispatcher = _a.dispatcher, _b = _a.flushInterval, flushInterval = _b === void 0 ? 30000 : _b, _c = _a.maxQueueSize, maxQueueSize = _c === void 0 ? 3000 : _c, notificationCenter = _a.notificationCenter;
        var _this = this;
        this.dispatcher = dispatcher;
        if (flushInterval <= 0) {
            logger.warn("Invalid flushInterval " + flushInterval + ", defaulting to " + DEFAULT_FLUSH_INTERVAL);
            flushInterval = DEFAULT_FLUSH_INTERVAL;
        }
        maxQueueSize = Math.floor(maxQueueSize);
        if (maxQueueSize < 1) {
            logger.warn("Invalid maxQueueSize " + maxQueueSize + ", defaulting to " + DEFAULT_MAX_QUEUE_SIZE);
            maxQueueSize = DEFAULT_MAX_QUEUE_SIZE;
        }
        maxQueueSize = Math.max(1, maxQueueSize);
        if (maxQueueSize > 1) {
            this.queue = new eventQueue_1.DefaultEventQueue({
                flushInterval: flushInterval,
                maxQueueSize: maxQueueSize,
                sink: function (buffer) { return _this.drainQueue(buffer); },
                batchComparator: events_1.areEventContextsEqual,
            });
        }
        else {
            this.queue = new eventQueue_1.SingleEventQueue({
                sink: function (buffer) { return _this.drainQueue(buffer); },
            });
        }
        this.notificationCenter = notificationCenter;
    }
    AbstractEventProcessor.prototype.drainQueue = function (buffer) {
        var _this = this;
        return new Promise(function (resolve) {
            logger.debug('draining queue with %s events', buffer.length);
            if (buffer.length === 0) {
                resolve();
                return;
            }
            var formattedEvent = _this.formatEvents(buffer);
            _this.dispatcher.dispatchEvent(formattedEvent, function () {
                resolve();
            });
            if (_this.notificationCenter) {
                _this.notificationCenter.sendNotifications(js_sdk_utils_1.NOTIFICATION_TYPES.LOG_EVENT, formattedEvent);
            }
        });
    };
    AbstractEventProcessor.prototype.process = function (event) {
        this.queue.enqueue(event);
    };
    AbstractEventProcessor.prototype.stop = function () {
        try {
            // swallow, an error stopping this queue should prevent this from stopping
            return this.queue.stop();
        }
        catch (e) {
            logger.error('Error stopping EventProcessor: "%s"', e.message, e);
        }
        return Promise.resolve();
    };
    AbstractEventProcessor.prototype.start = function () {
        this.queue.start();
    };
    return AbstractEventProcessor;
}());
exports.AbstractEventProcessor = AbstractEventProcessor;

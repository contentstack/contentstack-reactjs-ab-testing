'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var logging = require('@optimizely/js-sdk-logging');
var hoistNonReactStatics = _interopDefault(require('hoist-non-react-statics'));
var optimizely = require('@optimizely/optimizely-sdk');

/**
 * Copyright 2018-2019, Optimizely
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a = React.createContext({
    optimizely: null,
    isServerSide: false,
    timeout: 0,
}), Consumer = _a.Consumer, Provider = _a.Provider;
var OptimizelyContextConsumer = Consumer;
var OptimizelyContextProvider = Provider;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * Copyright 2019, Optimizely
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function areUsersEqual(user1, user2) {
    if (user1.id !== user2.id) {
        return false;
    }
    var user1keys = Object.keys(user1.attributes);
    var user2keys = Object.keys(user2.attributes);
    user1keys.sort();
    user2keys.sort();
    var areKeysLenEqual = user1keys.length === user2keys.length;
    if (!areKeysLenEqual) {
        return false;
    }
    for (var i = 0; i < user1keys.length; i++) {
        var key1 = user1keys[i];
        var key2 = user2keys[i];
        if (key1 !== key2) {
            return false;
        }
        if (user1.attributes[key1] !== user2.attributes[key2]) {
            return false;
        }
    }
    return true;
}
function hoistStaticsAndForwardRefs(Target, Source, displayName) {
    // Make sure to hoist statics and forward any refs through from Source to Target
    // From the React docs:
    //   https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over
    //   https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components
    var forwardRef = function (props, ref) { return (React.createElement(Target, __assign({}, props, { forwardedRef: ref }))); };
    forwardRef.displayName = displayName + "(" + (Source.displayName || Source.name) + ")";
    return hoistNonReactStatics(React.forwardRef(forwardRef), Source);
}

var logger = logging.getLogger('<OptimizelyProvider>');
var OptimizelyProvider = /** @class */ (function (_super) {
    __extends(OptimizelyProvider, _super);
    function OptimizelyProvider(props) {
        var _this = _super.call(this, props) || this;
        var optimizely = props.optimizely, userId = props.userId, userAttributes = props.userAttributes, user = props.user;
        // check if user id/attributes are provided as props and set them ReactSDKClient
        var finalUser = null;
        if (user) {
            if ('then' in user) {
                user.then(function (user) {
                    optimizely.setUser(user);
                });
            }
            else {
                finalUser = {
                    id: user.id,
                    attributes: user.attributes || {},
                };
            }
        }
        else if (userId) {
            finalUser = {
                id: userId,
                attributes: userAttributes || {},
            };
            // deprecation warning
            logger.warn('Passing userId and userAttributes as props is deprecated, please switch to using `user` prop');
        }
        if (finalUser) {
            optimizely.setUser(finalUser);
        }
        return _this;
    }
    OptimizelyProvider.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.isServerSide) {
            // dont react to updates on server
            return;
        }
        var optimizely = this.props.optimizely;
        if (this.props.user && 'id' in this.props.user) {
            if (!optimizely.user.id) {
                // no user is set in optimizely, update
                optimizely.setUser(this.props.user);
            }
            else if (
            // if the users aren't equal update
            !areUsersEqual({
                id: optimizely.user.id,
                attributes: optimizely.user.attributes,
            }, {
                id: this.props.user.id,
                // TODO see if we can use computeDerivedStateFromProps
                attributes: this.props.user.attributes || {},
            })) {
                optimizely.setUser(this.props.user);
            }
        }
    };
    OptimizelyProvider.prototype.render = function () {
        var _a = this.props, optimizely = _a.optimizely, children = _a.children, timeout = _a.timeout;
        var isServerSide = !!this.props.isServerSide;
        var value = {
            optimizely: optimizely,
            isServerSide: isServerSide,
            timeout: timeout,
        };
        return (React.createElement(OptimizelyContextProvider, { value: value }, children));
    };
    return OptimizelyProvider;
}(React.Component));

function withOptimizely(Component) {
    var WithOptimizely = /** @class */ (function (_super) {
        __extends(WithOptimizely, _super);
        function WithOptimizely() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WithOptimizely.prototype.render = function () {
            var _a = this.props, forwardedRef = _a.forwardedRef, rest = __rest(_a, ["forwardedRef"]);
            // Note: Casting props to P is necessary because of this TypeScript issue:
            // https://github.com/microsoft/TypeScript/issues/28884
            return (React.createElement(OptimizelyContextConsumer, null, function (value) { return (React.createElement(Component, __assign({}, rest, { optimizelyReadyTimeout: value.timeout, optimizely: value.optimizely, isServerSide: value.isServerSide, ref: forwardedRef }))); }));
        };
        return WithOptimizely;
    }(React.Component));
    var withRefsForwarded = hoistStaticsAndForwardRefs(WithOptimizely, Component, 'withOptimizely');
    return withRefsForwarded;
}

/**
 * Copyright 2019-2020, Optimizely
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var logger$1 = logging.getLogger('ReactSDK');
var REACT_SDK_CLIENT_ENGINE = 'react-sdk';
var REACT_SDK_CLIENT_VERSION = '1.1.0';
var DEFAULT_ON_READY_TIMEOUT = 5000;
var OptimizelyReactSDKClient = /** @class */ (function () {
    /**
     * Creates an instance of OptimizelyReactSDKClient.
     * @param {optimizely.Config} [config={}]
     */
    function OptimizelyReactSDKClient(config) {
        var _this = this;
        this.user = {
            id: null,
            attributes: {},
        };
        this.isUserPromiseResolved = false;
        this.onUserUpdateHandlers = [];
        this.initialConfig = config;
        this.userPromiseResovler = function () { };
        var configWithClientInfo = __assign({}, config, { clientEngine: REACT_SDK_CLIENT_ENGINE, clientVersion: REACT_SDK_CLIENT_VERSION });
        this._client = optimizely.createInstance(configWithClientInfo);
        this.userPromise = new Promise(function (resolve) {
            _this.userPromiseResovler = resolve;
        }).then(function () { return ({ success: true }); });
        this.dataReadyPromise = Promise.all([this.userPromise, this._client.onReady()]).then(function () {
            return {
                success: true,
                reason: 'datafile and user resolved',
            };
        });
    }
    OptimizelyReactSDKClient.prototype.onReady = function (config) {
        if (config === void 0) { config = {}; }
        var timeoutId;
        var timeout = DEFAULT_ON_READY_TIMEOUT;
        if (config && config.timeout !== undefined) {
            timeout = config.timeout;
        }
        var timeoutPromise = new Promise(function (resolve) {
            timeoutId = setTimeout(function () {
                resolve({
                    success: false,
                    reason: 'failed to initialize onReady before timeout, either the datafile or user info was not set before the timeout',
                });
            }, timeout);
        });
        return Promise.race([this.dataReadyPromise, timeoutPromise]).then(function (res) {
            clearTimeout(timeoutId);
            return res;
        });
    };
    OptimizelyReactSDKClient.prototype.setUser = function (userInfo) {
        var _this = this;
        // TODO add check for valid user
        if (userInfo.id) {
            this.user.id = userInfo.id;
        }
        if (userInfo.attributes) {
            this.user.attributes = userInfo.attributes;
        }
        if (!this.isUserPromiseResolved) {
            this.userPromiseResovler(this.user);
            this.isUserPromiseResolved = true;
        }
        this.onUserUpdateHandlers.forEach(function (handler) { return handler(_this.user); });
    };
    OptimizelyReactSDKClient.prototype.onUserUpdate = function (handler) {
        var _this = this;
        this.onUserUpdateHandlers.push(handler);
        return function () {
            var ind = _this.onUserUpdateHandlers.indexOf(handler);
            if (ind > -1) {
                _this.onUserUpdateHandlers.splice(ind, 1);
            }
        };
    };
    /**
     * Buckets visitor and sends impression event to Optimizely
     * @param {string} experimentKey
     * @param {string} [overrideUserId]
     * @param {optimizely.UserAttributes} [overrideAttributes]
     * @returns {(string | null)}
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.activate = function (experimentKey, overrideUserId, overrideAttributes) {
        var user = this.getUserContextWithOverrides(overrideUserId, overrideAttributes);
        if (user.id === null) {
            logger$1.info('Not activating experiment "%s" because userId is not set', experimentKey);
            return null;
        }
        return this._client.activate(experimentKey, user.id, user.attributes);
    };
    /**
     * Gets variation where visitor will be bucketed
     * @param {string} experimentKey
     * @param {string} [overrideUserId]
     * @param {optimizely.UserAttributes} [overrideAttributes]
     * @returns {(string | null)}
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.getVariation = function (experimentKey, overrideUserId, overrideAttributes) {
        var user = this.getUserContextWithOverrides(overrideUserId, overrideAttributes);
        if (user.id === null) {
            logger$1.info('getVariation returned null for experiment "%s" because userId is not set', experimentKey);
            return null;
        }
        return this._client.getVariation(experimentKey, user.id, user.attributes);
    };
    /**
     * Sends conversion event to Optimizely
     * @param {string} eventKey
     * @param {string} [overrideUserId]
     * @param {optimizely.UserAttributes} [overrideAttributes]
     * @param {optimizely.EventTags} [eventTags]
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.track = function (eventKey, overrideUserId, overrideAttributes, eventTags) {
        if (typeof overrideUserId !== 'undefined' && typeof overrideUserId !== 'string') {
            eventTags = overrideUserId;
            overrideUserId = undefined;
            overrideAttributes = undefined;
        }
        var user = this.getUserContextWithOverrides(overrideUserId, overrideAttributes);
        if (user.id === null) {
            logger$1.info('track for event "%s" not being sent because userId is not set', eventKey);
            return;
        }
        return this._client.track(eventKey, user.id, user.attributes, eventTags);
    };
    /**
     * Returns true if the feature is enabled for the given user
     * @param {string} feature
     * @param {string} [overrideUserId]
     * @param {optimizely.UserAttributes} [overrideAttributes]
     * @returns {boolean}
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.isFeatureEnabled = function (feature, overrideUserId, overrideAttributes) {
        var user = this.getUserContextWithOverrides(overrideUserId, overrideAttributes);
        if (user.id === null) {
            logger$1.info('isFeatureEnabled returning false for feature "%s" because userId is not set', feature);
            return false;
        }
        return this._client.isFeatureEnabled(feature, user.id, user.attributes);
    };
    /**
     * Get all variables for a feature, regardless of the feature being enabled/disabled
     * @param {string} feature
     * @param {string} [overrideUserId]
     * @param {optimizely.UserAttributes} [overrideAttributes]
     * @returns {VariableValuesObject}
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.getFeatureVariables = function (featureKey, overrideUserId, overrideAttributes) {
        var _this = this;
        var user = this.getUserContextWithOverrides(overrideUserId, overrideAttributes);
        var userId = user.id;
        if (userId === null) {
            logger$1.info('getFeatureVariables returning `{}` for feature "%s" because userId is not set', featureKey);
            return {};
        }
        var userAttributes = user.attributes;
        var variableObj = {};
        var config = this._client.projectConfigManager.getConfig();
        if (!config) {
            return {};
        }
        var feature = config.featureKeyMap[featureKey];
        if (!feature) {
            return {};
        }
        var variables = feature.variables;
        variables.forEach(function (variableDef) {
            var type = variableDef.type;
            var key = variableDef.key;
            switch (type) {
                case 'string':
                    variableObj[key] = _this._client.getFeatureVariableString(featureKey, key, userId, userAttributes);
                    break;
                case 'boolean':
                    variableObj[key] = _this._client.getFeatureVariableBoolean(featureKey, key, userId, userAttributes);
                    break;
                case 'integer':
                    variableObj[key] = _this._client.getFeatureVariableInteger(featureKey, key, userId, userAttributes);
                    break;
                case 'double':
                    variableObj[key] = _this._client.getFeatureVariableDouble(featureKey, key, userId, userAttributes);
                    break;
            }
        });
        return variableObj;
    };
    /**
     * Returns value for the given string variable attached to the given feature
     * flag
     * @param {string} feature
     * @param {string} variable
     * @param {string} [overrideUserId]
     * @param {optimizely.UserAttributes} [overrideAttributes]
     * @returns {(string | null)}
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.getFeatureVariableString = function (feature, variable, overrideUserId, overrideAttributes) {
        var user = this.getUserContextWithOverrides(overrideUserId, overrideAttributes);
        if (user.id === null) {
            return null;
        }
        return this._client.getFeatureVariableString(feature, variable, user.id, user.attributes);
    };
    /**
     * Returns value for the given boolean variable attached to the given feature
     * flag
     * @param {string} feature
     * @param {string} variable
     * @param {string} [overrideUserId]
     * @param {optimizely.UserAttributes} [overrideAttributes]
     * @returns {(string | null)}
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.getFeatureVariableBoolean = function (feature, variable, overrideUserId, overrideAttributes) {
        var user = this.getUserContextWithOverrides(overrideUserId, overrideAttributes);
        if (user.id === null) {
            return null;
        }
        return this._client.getFeatureVariableBoolean(feature, variable, user.id, user.attributes);
    };
    /**
     * Returns value for the given integer variable attached to the given feature
     * flag
     * @param {string} feature
     * @param {string} variable
     * @param {string} [overrideUserId]
     * @param {optimizely.UserAttributes} [overrideAttributes]
     * @returns {(string | null)}
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.getFeatureVariableInteger = function (feature, variable, overrideUserId, overrideAttributes) {
        var user = this.getUserContextWithOverrides(overrideUserId, overrideAttributes);
        if (user.id === null) {
            return null;
        }
        return this._client.getFeatureVariableInteger(feature, variable, user.id, user.attributes);
    };
    /**
     * Returns value for the given double variable attached to the given feature
     * flag
     * @param {string} feature
     * @param {string} variable
     * @param {string} [overrideUserId]
     * @param {optimizely.UserAttributes} [overrideAttributes]
     * @returns {(string | null)}
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.getFeatureVariableDouble = function (feature, variable, overrideUserId, overrideAttributes) {
        var user = this.getUserContextWithOverrides(overrideUserId, overrideAttributes);
        if (user.id === null) {
            return null;
        }
        return this._client.getFeatureVariableDouble(feature, variable, user.id, user.attributes);
    };
    /**
     * Get an array of all enabled features
     * @param {string} [overrideUserId]
     * @param {optimizely.UserAttributes} [overrideUserId]
     * @returns {Array<string>}
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.getEnabledFeatures = function (overrideUserId, overrideAttributes) {
        var user = this.getUserContextWithOverrides(overrideUserId, overrideAttributes);
        if (user.id === null) {
            return [];
        }
        return this._client.getEnabledFeatures(user.id, user.attributes);
    };
    /**
     * Gets the forced variation for a given user and experiment
     * @param {string} experiment
     * @param {string} [overrideUserId]
     * @returns {(string | null)}
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.getForcedVariation = function (experiment, overrideUserId) {
        var user = this.getUserContextWithOverrides(overrideUserId);
        if (user.id === null) {
            return null;
        }
        return this._client.getForcedVariation(experiment, user.id);
    };
    /**
     * Force a user into a variation for a given experiment
     * @param {string} experiment
     * @param {string} overrideUserIdOrVariationKey
     * @param {string} [variationKey]
     * @returns {boolean}
     * @memberof OptimizelyReactSDKClient
     */
    OptimizelyReactSDKClient.prototype.setForcedVariation = function (experiment, overrideUserIdOrVariationKey, variationKey) {
        var finalUserId = null;
        var finalVariationKey = null;
        if (arguments.length === 2) {
            finalVariationKey = overrideUserIdOrVariationKey;
            finalUserId = this.getUserContextWithOverrides().id;
        }
        else if (arguments.length === 3) {
            finalUserId = this.getUserContextWithOverrides(overrideUserIdOrVariationKey).id;
            if (variationKey === undefined) {
                // can't have undefined if supplying all 3 arguments
                return false;
            }
            finalVariationKey = variationKey;
        }
        if (finalUserId === null) {
            return false;
        }
        return this._client.setForcedVariation(experiment, finalUserId, finalVariationKey);
    };
    /**
     *  Returns OptimizelyConfig object containing experiments and features data
     *  @returns {optimizely.OptimizelyConfig | null} optimizely config
     */
    OptimizelyReactSDKClient.prototype.getOptimizelyConfig = function () {
        return this._client.getOptimizelyConfig();
    };
    /**
     * Cleanup method for killing an running timers and flushing eventQueue
     */
    OptimizelyReactSDKClient.prototype.close = function () {
        return this._client.close();
    };
    Object.defineProperty(OptimizelyReactSDKClient.prototype, "client", {
        /**
         * Provide access to inner optimizely.Client object
         */
        get: function () {
            return this._client;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OptimizelyReactSDKClient.prototype, "notificationCenter", {
        get: function () {
            return this._client.notificationCenter;
        },
        enumerable: true,
        configurable: true
    });
    OptimizelyReactSDKClient.prototype.getUserContextWithOverrides = function (overrideUserId, overrideAttributes) {
        var finalUserId = overrideUserId === undefined ? this.user.id : overrideUserId;
        var finalUserAttributes = overrideAttributes === undefined ? this.user.attributes : overrideAttributes;
        return {
            id: finalUserId,
            attributes: finalUserAttributes,
        };
    };
    return OptimizelyReactSDKClient;
}());
function createInstance(config) {
    return new OptimizelyReactSDKClient(config);
}

var logger$2 = logging.getLogger('<OptimizelyFeature>');
var FeatureComponent = /** @class */ (function (_super) {
    __extends(FeatureComponent, _super);
    function FeatureComponent(props) {
        var _this = _super.call(this, props) || this;
        _this.autoUpdate = false;
        _this.unregisterUserListener = function () { };
        var autoUpdate = props.autoUpdate, isServerSide = props.isServerSide, optimizely = props.optimizely, feature = props.feature;
        _this.autoUpdate = !!autoUpdate;
        if (isServerSide) {
            if (optimizely === null) {
                throw new Error('optimizely prop must be supplied');
            }
            var isEnabled = optimizely.isFeatureEnabled(feature);
            var variables = optimizely.getFeatureVariables(feature);
            _this.state = {
                canRender: true,
                isEnabled: isEnabled,
                variables: variables,
            };
        }
        else {
            _this.state = {
                canRender: false,
                isEnabled: false,
                variables: {},
            };
        }
        return _this;
    }
    FeatureComponent.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, feature = _a.feature, optimizely = _a.optimizely, optimizelyReadyTimeout = _a.optimizelyReadyTimeout, isServerSide = _a.isServerSide, timeout = _a.timeout;
        if (optimizely === null) {
            throw new Error('optimizely prop must be supplied');
        }
        if (isServerSide) {
            return;
        }
        // allow overriding of the ready timeout via the `timeout` prop passed to <Experiment />
        var finalReadyTimeout = timeout !== undefined ? timeout : optimizelyReadyTimeout;
        optimizely.onReady({ timeout: finalReadyTimeout }).then(function (res) {
            if (res.success) {
                logger$2.info('feature="%s" successfully rendered for user="%s"', feature, optimizely.user.id);
            }
            else {
                logger$2.info('feature="%s" could not be checked before timeout of %sms, reason="%s" ', feature, timeout === undefined ? DEFAULT_ON_READY_TIMEOUT : timeout, res.reason || '');
            }
            var isEnabled = optimizely.isFeatureEnabled(feature);
            var variables = optimizely.getFeatureVariables(feature);
            _this.setState({
                canRender: true,
                isEnabled: isEnabled,
                variables: variables,
            });
            if (_this.autoUpdate) {
                _this.setupAutoUpdateListeners();
            }
        });
    };
    FeatureComponent.prototype.setupAutoUpdateListeners = function () {
        var _this = this;
        var _a = this.props, optimizely = _a.optimizely, feature = _a.feature;
        if (optimizely === null) {
            return;
        }
        this.optimizelyNotificationId = optimizely.notificationCenter.addNotificationListener('OPTIMIZELY_CONFIG_UPDATE', function () {
            logger$2.info('OPTIMIZELY_CONFIG_UPDATE, re-evaluating feature="%s" for user="%s"', feature, optimizely.user.id);
            var isEnabled = optimizely.isFeatureEnabled(feature);
            var variables = optimizely.getFeatureVariables(feature);
            _this.setState({
                isEnabled: isEnabled,
                variables: variables,
            });
        });
        this.unregisterUserListener = optimizely.onUserUpdate(function () {
            logger$2.info('User update, re-evaluating feature="%s" for user="%s"', feature, optimizely.user.id);
            var isEnabled = optimizely.isFeatureEnabled(feature);
            var variables = optimizely.getFeatureVariables(feature);
            _this.setState({
                isEnabled: isEnabled,
                variables: variables,
            });
        });
    };
    FeatureComponent.prototype.componentWillUnmount = function () {
        var _a = this.props, optimizely = _a.optimizely, isServerSide = _a.isServerSide;
        if (isServerSide || !this.autoUpdate) {
            return;
        }
        if (optimizely && this.optimizelyNotificationId) {
            optimizely.notificationCenter.removeNotificationListener(this.optimizelyNotificationId);
        }
        this.unregisterUserListener();
    };
    FeatureComponent.prototype.render = function () {
        var children = this.props.children;
        var _a = this.state, isEnabled = _a.isEnabled, variables = _a.variables, canRender = _a.canRender;
        if (!canRender) {
            return null;
        }
        return children(isEnabled, variables);
    };
    return FeatureComponent;
}(React.Component));
var OptimizelyFeature = withOptimizely(FeatureComponent);

var logger$3 = logging.getLogger('<OptimizelyExperiment>');
var Experiment = /** @class */ (function (_super) {
    __extends(Experiment, _super);
    function Experiment(props) {
        var _this = _super.call(this, props) || this;
        _this.unregisterUserListener = function () { };
        _this.autoUpdate = false;
        var autoUpdate = props.autoUpdate, isServerSide = props.isServerSide, optimizely = props.optimizely, experiment = props.experiment;
        _this.autoUpdate = !!autoUpdate;
        if (isServerSide) {
            if (optimizely === null) {
                throw new Error('optimizely prop must be supplied');
            }
            var variation = optimizely.activate(experiment);
            _this.state = {
                canRender: true,
                variation: variation,
            };
        }
        else {
            _this.state = {
                canRender: false,
                variation: null,
            };
        }
        return _this;
    }
    Experiment.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, experiment = _a.experiment, optimizely = _a.optimizely, optimizelyReadyTimeout = _a.optimizelyReadyTimeout, isServerSide = _a.isServerSide, timeout = _a.timeout;
        if (!optimizely) {
            throw new Error('optimizely prop must be supplied');
        }
        if (isServerSide) {
            return;
        }
        // allow overriding of the ready timeout via the `timeout` prop passed to <Experiment />
        var finalReadyTimeout = timeout !== undefined ? timeout : optimizelyReadyTimeout;
        optimizely.onReady({ timeout: finalReadyTimeout }).then(function (res) {
            if (res.success) {
                logger$3.info('experiment="%s" successfully rendered for user="%s"', experiment, optimizely.user.id);
            }
            else {
                logger$3.info('experiment="%s" could not be checked before timeout of %sms, reason="%s" ', experiment, timeout === undefined ? DEFAULT_ON_READY_TIMEOUT : timeout, res.reason || '');
            }
            var variation = optimizely.activate(experiment);
            _this.setState({
                canRender: true,
                variation: variation,
            });
            if (_this.autoUpdate) {
                _this.setupAutoUpdateListeners();
            }
        });
    };
    Experiment.prototype.setupAutoUpdateListeners = function () {
        var _this = this;
        var _a = this.props, optimizely = _a.optimizely, experiment = _a.experiment;
        if (optimizely === null) {
            return;
        }
        this.optimizelyNotificationId = optimizely.notificationCenter.addNotificationListener('OPTIMIZELY_CONFIG_UPDATE', function () {
            logger$3.info('OPTIMIZELY_CONFIG_UPDATE, re-evaluating experiment="%s" for user="%s"', experiment, optimizely.user.id);
            var variation = optimizely.activate(experiment);
            _this.setState({
                variation: variation,
            });
        });
        this.unregisterUserListener = optimizely.onUserUpdate(function () {
            logger$3.info('User update, re-evaluating experiment="%s" for user="%s"', experiment, optimizely.user.id);
            var variation = optimizely.activate(experiment);
            _this.setState({
                variation: variation,
            });
        });
    };
    Experiment.prototype.componentWillUnmount = function () {
        var _a = this.props, optimizely = _a.optimizely, isServerSide = _a.isServerSide;
        if (isServerSide || !this.autoUpdate) {
            return;
        }
        if (optimizely && this.optimizelyNotificationId) {
            optimizely.notificationCenter.removeNotificationListener(this.optimizelyNotificationId);
        }
        this.unregisterUserListener();
    };
    Experiment.prototype.render = function () {
        var children = this.props.children;
        var _a = this.state, variation = _a.variation, canRender = _a.canRender;
        if (!canRender) {
            return null;
        }
        if (children != null && typeof children === 'function') {
            return children(variation);
        }
        var match = null;
        // We use React.Children.forEach instead of React.Children.toArray().find()
        // here because toArray adds keys to all child elements and we do not want
        // to trigger an unmount/remount
        React.Children.forEach(this.props.children, function (child) {
            if (match || !React.isValidElement(child)) {
                return;
            }
            if (child.props.variation) {
                if (variation === child.props.variation) {
                    match = child;
                }
            }
            else if (child.props.default) {
                match = child;
            }
        });
        return match ? React.cloneElement(match, { variation: variation }) : null;
    };
    return Experiment;
}(React.Component));
var OptimizelyExperiment = withOptimizely(Experiment);

var Variation = /** @class */ (function (_super) {
    __extends(Variation, _super);
    function Variation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Variation.prototype.render = function () {
        return this.props.children;
    };
    return Variation;
}(React.Component));
var OptimizelyVariation = Variation;

/**
 * Copyright 2019, Optimizely
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var logger$4 = logging.getLogger('ReactSDK');
/**
 * logOnlyEventDispatcher only logs a message at the debug level, and does not
 * send any requests to the Optimizely results backend. Use this to disable
 * all event dispatching.
 */
var logOnlyEventDispatcher = {
    dispatchEvent: function (event, callback) {
        logger$4.debug('Event not dispatched by disabled event dispatcher: %s', function () {
            var eventStr;
            try {
                eventStr = JSON.stringify(event);
            }
            catch (err) {
                eventStr = 'error stringifying event';
            }
            return eventStr;
        });
    }
};

/**
 * Copyright 2018-2019, Optimizely
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, 'enums', {
  enumerable: true,
  get: function () {
    return optimizely.enums;
  }
});
Object.defineProperty(exports, 'errorHandler', {
  enumerable: true,
  get: function () {
    return optimizely.errorHandler;
  }
});
Object.defineProperty(exports, 'eventDispatcher', {
  enumerable: true,
  get: function () {
    return optimizely.eventDispatcher;
  }
});
Object.defineProperty(exports, 'logging', {
  enumerable: true,
  get: function () {
    return optimizely.logging;
  }
});
Object.defineProperty(exports, 'setLogLevel', {
  enumerable: true,
  get: function () {
    return optimizely.setLogLevel;
  }
});
Object.defineProperty(exports, 'setLogger', {
  enumerable: true,
  get: function () {
    return optimizely.setLogger;
  }
});
exports.OptimizelyContextConsumer = OptimizelyContextConsumer;
exports.OptimizelyContextProvider = OptimizelyContextProvider;
exports.OptimizelyExperiment = OptimizelyExperiment;
exports.OptimizelyFeature = OptimizelyFeature;
exports.OptimizelyProvider = OptimizelyProvider;
exports.OptimizelyVariation = OptimizelyVariation;
exports.createInstance = createInstance;
exports.logOnlyEventDispatcher = logOnlyEventDispatcher;
exports.withOptimizely = withOptimizely;
